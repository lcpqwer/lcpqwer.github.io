<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL</title>
    <url>/2020/05/16/MySQL/</url>
    <content><![CDATA[<h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">分类：</span><br><span class="line">数据库定义语言   DDL（create database/table，drop database/table，alter database/table）</span><br><span class="line">数据库操纵语言   DML(insert、delete、update、select)</span><br><span class="line">数据库控制语言   DCL（grant、revoke）</span><br><span class="line">注意，数据库定义语言和数据库控制语言都是不可撤销的。而数据库操作语言是可以撤销 。</span><br></pre></td></tr></table></figure>
<h4 id="数据库定义语言"><a href="#数据库定义语言" class="headerlink" title="数据库定义语言"></a>数据库定义语言</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）、创建数据库</span><br><span class="line">    create database 数据库名；</span><br><span class="line"></span><br><span class="line">2）、删除数据库</span><br><span class="line">    drop database 数据库名；</span><br><span class="line"></span><br><span class="line">3）、打开数据库</span><br><span class="line">    use 数据库名；</span><br><span class="line"></span><br><span class="line">4）创建数据表</span><br><span class="line">    create table 表名(列名 数据类型(长度),列名 数据类型（长度）,......) default charset=utf8</span><br><span class="line">    注意，如果创建表的时候，没有指定字符集，那么该表将默认采用其所在数据库的字符集。通常我们建议指定缺省的字符集。</span><br><span class="line"></span><br><span class="line">5)、查看数据表的字符集情况</span><br><span class="line">    show variables like <span class="string">'character%'</span>;</span><br><span class="line"></span><br><span class="line">6）查看表结构</span><br><span class="line">    desc 表名</span><br><span class="line"></span><br><span class="line">7）、数据库字段类型</span><br><span class="line">字符类型：</span><br><span class="line">    char(长度)：定长的字符类型，一旦声明了长度，即使定义的字段数据不能达到最大长度，也会按照最大长度进行所占字节的分配。取值范围：0-255</span><br><span class="line">    varchar(长度)： 变长的字符类型，声明长度后，如果字段数据的长度达不到最大长度，则会根据实际长度给出数据的长度。取值范围：0-2^16-1</span><br><span class="line"></span><br><span class="line">数值类型：</span><br><span class="line">    int(长度)：给出指定的字段数据长度。如果没有明确指定长度，则采用默认长度11。所占字节4个字节。</span><br><span class="line"></span><br><span class="line">日期类型：</span><br><span class="line">    date：日期类型的字段，在定义时不需要指定长度。格式为YYYY-MM-DD</span><br><span class="line">    time：日期类型的字段，格式HH:MM:SS</span><br><span class="line">    datatime：日期类型的字段，格式YYYY-MM-DD HH:MM:SS</span><br><span class="line">    布尔型：</span><br><span class="line">    bool:布尔类型的字段，在定义时采用0代表假，1代表真。</span><br><span class="line">    实际在mysql数据库中，bool类型等同于数值型的tinyint(1)</span><br><span class="line"></span><br><span class="line">8)、修改表结构</span><br><span class="line">    alter table 表名 [add/modify/change/drop] 字段名 [数据类型]</span><br><span class="line">    添加字段,位于表中的最后一列：</span><br><span class="line">    alter table tablename add 字段名 数据类型；</span><br><span class="line">    删除一列，如果列中有数据，则全部被删除且不可恢复:</span><br><span class="line">    alter table tablename drop 字段名</span><br><span class="line">    修改指定字段的数据类型及长度:</span><br><span class="line">    alter talbe tablename modify 字段名 数据类型</span><br><span class="line">    修改指定字段的名字</span><br><span class="line">    alter table tablename change oldcolumn newcolumn 数据类型</span><br><span class="line"></span><br><span class="line">9）、修改表名</span><br><span class="line">    rename table 旧表名 to 新表名</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫</title>
    <url>/2020/05/15/Python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、HTTP与HTTPS的区别</span><br><span class="line">    HTTP：我们称为超文本传输协议，主要用来实现从网络传输超文本到本地浏览器，实现高效且准确的超文本传送。目前HTTP的版本为1.1</span><br><span class="line">    HTTPS：我们认为就是以安全为目标的HTTP通道，即在HTTP协议的基础上加入了SSL层，简称HTTPS。</span><br><span class="line">    SSL的主要作用分为以下两部分：</span><br><span class="line">    第一、为HTTP传输文件提供安全的传输通道</span><br><span class="line">    第二、确认网站的真实性，通过HTTPS访问的网站都需要获取到CA认证。</span><br><span class="line"></span><br><span class="line">2、网络七层模型（了解）</span><br><span class="line">    从下到上的顺序</span><br><span class="line">    物理层</span><br><span class="line">    数据链路层</span><br><span class="line">    网络层</span><br><span class="line">    传输层（TCP、UDP）</span><br><span class="line">    会话层</span><br><span class="line">    表示层</span><br><span class="line">    应用层（HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP）</span><br><span class="line"></span><br><span class="line">3、HTTP的请求机制</span><br><span class="line">    第一，由客户端（浏览器）发出请求</span><br><span class="line">    第二，通过网络传输，到指定的服务器地址</span><br><span class="line">    第三，服务器接收相关请求，并进行解析</span><br><span class="line">    第四，服务器将最终的结果响应回客户端</span><br><span class="line">    第五，客户端接收到服务器响应后，通过浏览器解析，最终将内容进行展现</span><br><span class="line"></span><br><span class="line">4、客户端访问服务器，发出请求，有四部分构成</span><br><span class="line">    第一，请求方法（request method），默认为get方式。只有在表单提交和文件上传时为post方法。</span><br><span class="line">    第二，请求网址（request url），即在浏览器中输入的网路地址。</span><br><span class="line">    第三，请求头（request header），用来标识为一个浏览器正常的访问</span><br><span class="line">    第四，请求体（request body），用来传输到服务器端的相关数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5、请求方法中get与post的区别</span><br><span class="line">    第一、使用get方式提交请求时，相关数据会作为url的参数被一起进行提交，我们可以直接在地址栏中观察到相关数据。而采用post方式请求的url不会包含这些数据，而是直接通过表单提交到服务器。</span><br><span class="line">    第二、get方式提交请求，对于提交的数据大小不能大于1024字节，而post方式提交数据，没有大小的限制。</span><br><span class="line">    总之，如果提交的信息比较敏感或者字节较大时，需要使用post方式；如果只是普通的请求使用get方式。</span><br></pre></td></tr></table></figure>
<h3 id="HTML网页结构"><a href="#HTML网页结构" class="headerlink" title="HTML网页结构"></a>HTML网页结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、HTML基本构成</span><br><span class="line">    HTML有三个标签来构成基本结构：</span><br><span class="line">    &lt;html&gt;:作为HTML文件的根标签，所有的页面中的标签和内容都要在HTML标签的范围内。</span><br><span class="line">    &lt;head&gt;：作为HTML文件的头部标签，相关页面的信息、编码、引导外部的CSS文件和JS文件，都需要放置在head标签中。</span><br><span class="line">    &lt;body&gt;：body标签中的内容，就是我们爬虫需要解析的主体。所有需要在页面上展现的内容，都会放置在该标签中。</span><br><span class="line"></span><br><span class="line">2、常见的HTML标签</span><br><span class="line">    1）h1...h6：标题标签，用来显示标题，h1最大，h6最小。</span><br><span class="line">    2）&lt;p&gt;：段落标签。用来对文本内容进行分段。</span><br><span class="line">    3）&lt;a&gt;：链接标签。用来跳转到指定的网址。</span><br><span class="line">    &lt;a target=<span class="string">''</span> href=<span class="string">'URL'</span>&gt;链接地址&lt;/a&gt;</span><br><span class="line">    其中参数target，_self:在自身的窗口重新打开指定的网址</span><br><span class="line">    _blank：在一个新窗口中打开指定的网址</span><br><span class="line"></span><br><span class="line">4）&lt;img&gt;：</span><br><span class="line">    图片标签。用来载入指定位置的图片，通常可以接收的图片类型：JPG、png、gif、bmp</span><br><span class="line">    &lt;img src=<span class="string">""</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    其中：src：指定图片的具体位置</span><br><span class="line">        alt：其中的内容，作为图片无法载入时，显示的内容。</span><br><span class="line"></span><br><span class="line">5）表格标签：table、tr、th、td</span><br><span class="line">    &lt;table&gt;：表格标签，所有表格中的行和单元格内容都必须放置在内部。</span><br><span class="line">    &lt;tr&gt;:表格行，代表表格一行</span><br><span class="line">    &lt;th&gt;:表格头，代表表格的标题行</span><br><span class="line">    &lt;td&gt;：表格单元格，代表表格中的每个单元内容</span><br><span class="line"></span><br><span class="line">6）列表</span><br><span class="line">有序列表：</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">无序列表:</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">自定义列表：</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">        &lt;dt&gt;</span><br><span class="line">            &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">        &lt;/dt&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line"></span><br><span class="line">7)div与span</span><br><span class="line">    div：块级元素，用来实现页面布局。自身没有任何效果</span><br><span class="line">    span:内联元素，用做文本容器。</span><br><span class="line"></span><br><span class="line">8）表单</span><br><span class="line">    &lt;form name=<span class="string">"表单名"</span> action=<span class="string">"URL"</span> method=<span class="string">"get/post"</span>&gt;</span><br><span class="line">    默认情况，如果没有声明method属性，缺省值为get</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">""</span>&gt;</span><br><span class="line">    输入标签，<span class="built_in">type</span>属性：</span><br><span class="line">    text:文本框</span><br><span class="line">    password：密码框</span><br><span class="line">    checkbox：复选框</span><br><span class="line">    radio：单选框</span><br><span class="line">    submit：提交按钮</span><br><span class="line">    reset：重置按钮</span><br><span class="line">    button：按钮</span><br><span class="line">    file:文件上传</span><br><span class="line">    &lt;textarea cols=<span class="string">"列数"</span> rows=<span class="string">"行数"</span>&gt;：文件区标签</span><br></pre></td></tr></table></figure>
<h3 id="网络爬虫——urllib库"><a href="#网络爬虫——urllib库" class="headerlink" title="网络爬虫——urllib库"></a>网络爬虫——urllib库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、urllib库的基本使用</span><br><span class="line">    import urllib.request</span><br><span class="line">    函数格式：urllib.request.openurl(url, data, timeout)</span><br><span class="line">    参数说明：</span><br><span class="line">    url：指定的请求网址</span><br><span class="line">    data：请求时提交给服务器端的数据，如果在openurl中使用了data参数，那么提交方式为post，默认情况下为get。</span><br><span class="line">    timeout：指定连接url的超时时间，单位为秒。</span><br><span class="line">    response = urllib.request.openurl()函数返回一个HTTPResponse对象</span><br><span class="line">    我们可以使用response对象中的相关方法：</span><br><span class="line">    <span class="built_in">read</span>()读取响应体中的内容</span><br><span class="line">    status/getcode()返回响应码</span><br><span class="line">    reason 返回响应信息的内容</span><br><span class="line">    info()返回响应头信息</span><br><span class="line">    geturl()返回请求的url地址</span><br><span class="line"></span><br><span class="line">2、Request请求对象</span><br><span class="line">    req = urllib.request.Request(url,data,headers,method)</span><br><span class="line">    参数说明：</span><br><span class="line">    url：指定的请求网址</span><br><span class="line">    data：请求时提交给服务器端的数据，如果在openurl中使用了data参数，那么提交方式为post，默认情况下为get。</span><br><span class="line">    headers：请求对象的头信息，用来将一个爬虫伪装成一个普通的浏览器请求，主要设置user-agent</span><br><span class="line">    method：请求的方式，默认为get，可以设置为get或post</span><br><span class="line"></span><br><span class="line">3、urllib.error</span><br><span class="line">    在urllib库中有三个error对象</span><br><span class="line">    HTTPError：HTTP访问异常</span><br><span class="line">    URLError：url地址异常</span><br><span class="line">    ContentTooShortError：文件大小异常</span><br><span class="line">    注意，HTTPError是URLError的子类。</span><br><span class="line">    HTTPError，只有一个属性reason</span><br><span class="line">    URLError，有code，reason，headers三个属性。</span><br><span class="line"></span><br><span class="line">4、urllib.robotparser</span><br><span class="line">    作用：用来解析指定网站的robots.txt文件。用来分析哪些内容是允许抓取，哪些内容是不允许的。</span><br></pre></td></tr></table></figure>
<h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）函数格式：requests.get(url,[param], **kvw)</span><br><span class="line">    参数说明:</span><br><span class="line">    url：指定爬取的网络地址</span><br><span class="line">    param：需要传递的参数，参数格式：字典或字节流</span><br><span class="line">    返回值：response对象</span><br><span class="line">    属性：</span><br><span class="line">    status_code:状态码</span><br><span class="line">    headers:头信息</span><br><span class="line">    text：抓取到的页面内容</span><br><span class="line">    encoding：页面的编码格式（从headers获取到）</span><br><span class="line">    apparent_encoding：页面的编码格式（从网页内容中获取到）</span><br><span class="line">    content：二进制形式的信息</span><br><span class="line">    注意：text属性返回的页面信息，是根据encoding来显示的。所以我们在使用requests抓取页面信息时，将encoding属性进行设置，通常设为utf-8。</span><br><span class="line"></span><br><span class="line">    get()函数代表了发出一个request请求，而requests.get()表示返回一个response对象</span><br><span class="line"></span><br><span class="line">2）结构</span><br><span class="line">    requests.request(<span class="string">'GET'</span>,url, **kvw)</span><br><span class="line">    requests.request(<span class="string">'HEAD'</span>,url, **kvw)</span><br><span class="line">    requests.request(<span class="string">'POST'</span>,url, **kvw)</span><br><span class="line">    requests.request(<span class="string">'PUT'</span>,url, **kvw)</span><br><span class="line">    requests.request(<span class="string">'PATCH'</span>,url, **kvw)</span><br><span class="line">    requests.request(<span class="string">'DELETE'</span>,url, **kvw)</span><br><span class="line">    **kvw:控制访问的参数，为可选项</span><br><span class="line">    params:字典或字节流，作为参数添加到url中（get方法使用）</span><br><span class="line">    data：字典、字节流或文件对象（post方法使用）</span><br><span class="line">    json：JSON格式数据，作为request的内容</span><br><span class="line">    headers：字典，HTTP头信息</span><br><span class="line">    cookies：字典或cookie jar，存在于request的cookie中</span><br><span class="line">    auth：元组，支持HTTP认证</span><br><span class="line">    files：字典类型，传输文件</span><br><span class="line">    timeout：设定超时时间，秒为单位</span><br><span class="line">    stream：True/False，默认为True。获取内容立即下载。</span><br><span class="line">    cert：本地SSL整数路径</span><br><span class="line">    verfiy：True/False，默认为True。认证SSL开关</span><br><span class="line">    allow_redirects：True/False,默认为True，重定向开发</span><br></pre></td></tr></table></figure>
<h3 id="beautiful-soup库"><a href="#beautiful-soup库" class="headerlink" title="beautiful soup库"></a>beautiful soup库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、常用格式</span><br><span class="line">    from bs4 import BeautifulSoup</span><br><span class="line">    soup = BeautifulSoup(content, <span class="string">'html.parser'</span>)</span><br><span class="line">    参数说明：</span><br><span class="line">    content：使用requests或其他方式，发出请求后获取到的服务器响应内容，通常应该为HTML格式。</span><br><span class="line">    html.parser:HTML4格式解析器</span><br><span class="line"></span><br><span class="line">2、常用的属性</span><br><span class="line">    标签自身属性：</span><br><span class="line">    tag：标签，例如soup.tag可以将指定的标签以及内部的内容返回</span><br><span class="line">    name：标签名，例如：soup.tag.name返回指定标签的名字</span><br><span class="line">    attrs：标签属性，在HTML中一个标签可以有0到N个标签，因此标签属性为字典类型，例如：soup.tag.attrs[<span class="string">'class'</span>]</span><br><span class="line">    string：标签内的文本内容，例如：soup.tag.string</span><br><span class="line">    标签树的属性：</span><br><span class="line">    contents:例如：soup.tag.contents,将指定的标签名内所有的标签都以列表形式返回。</span><br><span class="line">    children：例如：soup.tag.children，将指定的标签中所有的子标签内容，都以迭代器形式返回，进行遍历查询。</span><br><span class="line">    descendants：例如：soup.tag.descendants,将指定的标签中所有的子标签、孙标签都以迭代器形式返回，进行遍历查询。</span><br><span class="line">    注意：BeautifulSoup对象，作为标签树的根节点，即HTML节点</span><br><span class="line"></span><br><span class="line">3、常用方法</span><br><span class="line">    1）函数格式：soup.find(name,attrs)</span><br><span class="line">    参数说明：</span><br><span class="line">    name：标签名</span><br><span class="line">    attrs：标签中的属性值（属性=‘值’）</span><br><span class="line">    返回值：返回查找到第一个符合条件的标签以及内部元素</span><br><span class="line"></span><br><span class="line">    2）函数格式：soup.find_all(name,attrs)</span><br><span class="line">    函数参数与上面find()相同</span><br><span class="line">    返回值：返回符合条件的所有的标签，以列表形式返回。</span><br><span class="line"></span><br><span class="line">4、bs4的遍历模式</span><br><span class="line">    在BeautifulSoup中，有三种遍历模式：</span><br><span class="line">    1）下行遍历</span><br><span class="line">    children、descendants、contents</span><br><span class="line">    find()、find_all()</span><br><span class="line">    2）上行遍历</span><br><span class="line">    parent、parents</span><br><span class="line">    find_parent()、find_parents()</span><br><span class="line">    3）平行遍历</span><br><span class="line">    next_sibling、next_siblings</span><br><span class="line">    previous_sibling、previous_siblings</span><br><span class="line">    find_next_sibling()、find_next_siblings()</span><br><span class="line">    find_previous_siblings()、find_previous_sibling()</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、正则表达式的概念</span><br><span class="line">    正则表达式就是使用一些特定的表达式，来表示符合其规范的字符串。</span><br><span class="line"></span><br><span class="line">2、常用操作符</span><br><span class="line">    ^:^ab,代表着必须是ab开头，[^ab]代表不能是a或b开头</span><br><span class="line">    $:表示字符串结尾，放在正则表达式的结尾</span><br><span class="line">    []：代表了值域的范围，例如：[0-9][a-z]</span><br><span class="line">    &#123;&#125;：代表了字符出现的次数,例如：&#123;n&#125;代表了出现n次，&#123;n,m&#125;代表出现了n到m次</span><br><span class="line">    *:代表了字符出现0-n次</span><br><span class="line">    +：代表了字符出现1-n次</span><br><span class="line">    ？：代表了字符出现0-1次</span><br><span class="line"></span><br><span class="line">3、常用方法</span><br><span class="line">    1）search()：会在指定的字符串中查找，是否有匹配正则表达式的内容</span><br><span class="line">    函数格式：search(pattern, str)</span><br><span class="line">    参数说明：</span><br><span class="line">    pattern：正则表达式</span><br><span class="line">    str：字符串</span><br><span class="line">    返回值：match对象，可以通过match.group(0)返回匹配正则表达式的内容</span><br><span class="line">    2）match():会从字符串的开始进行匹配</span><br><span class="line">    函数格式：match(pattern, str) </span><br><span class="line">    返回值：match对象</span><br><span class="line">    3）findall():会从指定的字符串中，匹配所有满足正则表达式的内容</span><br><span class="line">    函数格式：findall(pattern,str)</span><br><span class="line">    返回值：返回所有匹配的内容，以列表形式。</span><br><span class="line">    4）split():根据字符串匹配正则表达式的情况来切分</span><br><span class="line">    函数格式：split(pattern, str, maxsplit)</span><br><span class="line">    maxsplit：最大切分次数，剩余部分将作为一个整体输出</span><br><span class="line">    返回值：将切分后的字符串，以列表形式返回</span><br><span class="line">    5）finditer():根据字符串匹配正则表达式，返回一个迭代对象，其中的每一个对象都是match对象</span><br><span class="line">    函数格式：finditer(pattern,str)</span><br><span class="line">    返回值：返回迭代对象，其中每个对象都是match类型</span><br><span class="line"></span><br><span class="line">    6）sub():根据正则表达式，将指定的字符串内容替换</span><br><span class="line">    函数格式：sub(pattern, repl, string, count)</span><br><span class="line">    参数说明：</span><br><span class="line">    repl：替换匹配字符串的字符串</span><br><span class="line">    count：匹配的最大次数</span><br><span class="line">    返回值：返回替换后的字符串</span><br><span class="line">    7）compile():生成正则表达式对象</span><br><span class="line">    函数格式：compile(pattern)</span><br><span class="line">    返回值：返回一个正则表达式对象</span><br><span class="line"></span><br><span class="line">4、match对象</span><br><span class="line">    1）match对象属性</span><br><span class="line">    string：待匹配的字符串</span><br><span class="line">    pos：匹配文本的开始位置</span><br><span class="line">    endpos：匹配文件的结束位置</span><br><span class="line">    re：正则表达式</span><br><span class="line">    2）match方法</span><br><span class="line">    group(0)：获得匹配后的字符串</span><br><span class="line">    start()：返回文本开始的位置</span><br><span class="line">    end()：返回文本结束的位置</span><br><span class="line">    span()：返回文本开始，结束的位置，以元组的形式返回</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2018/06/15/Python/</url>
    <content><![CDATA[<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在开发过程，对应不同的语言使用不同的字符编码。</span><br><span class="line">英文    ISO-8859-1</span><br><span class="line">中文    gbk或gb2312</span><br><span class="line">Unicode 是「字符集」:为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）</span><br><span class="line">目前Python为了统一编码格式，在3.0以上的版本使用了utf-8编码</span><br></pre></td></tr></table></figure>

<!-- More info: [Writing](https://hexo.io/docs/writing.html) -->

<h3 id="print-函数"><a href="#print-函数" class="headerlink" title="print()函数"></a>print()函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(1)语法格式：<span class="built_in">print</span>(value,...,sep=<span class="string">' '</span>,end=<span class="string">'\n'</span>)</span><br><span class="line">其中，value代表我们要输出的内容，可以是字符串，可以是数值等内容</span><br><span class="line">sep代表输出多个值之间的间隔符，默认使用空格隔开。我们可以重新定义间隔符，比如采用：<span class="comment">#、，等</span></span><br><span class="line">end代表输出语句的结束标识，默认使用了换行，我们可以重新定义其他内容，其输出的内容将不再进行换行操作。</span><br><span class="line"></span><br><span class="line">(2)基本使用方法：<span class="built_in">print</span>(<span class="string">'hello '</span>)、<span class="built_in">print</span>(123456)等</span><br><span class="line"></span><br><span class="line">(3)参数格式输出：%s：代表了字符串内容，其中</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'welcom %s'</span>%<span class="string">'beijing'</span>)=&gt;welcome beijing</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'welcome %10.3s'</span>%<span class="string">'Beijing'</span>)=&gt;welcome       Bei,输出结果为10个字符其中包含字符串Beijing中前三个，其余用空格填充</span><br><span class="line">            %d：代表了整数内容，其中</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'price %d'</span>%10)=&gt;price 10</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'price %d'</span>%10.5) =&gt; price 1</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'price %3d'</span>%10000)=&gt; price 10000</span><br><span class="line">注意这里面的3d表示输出一个宽度为3个单元的数值，如果数值长度小于三，那么数值靠右对齐。 -3d表示，数值反向对齐（靠左对齐）</span><br><span class="line">            %f：代表了浮点数内容(注意，在Python中浮点数是一个近似值，所以结果也是近似)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'price %f'</span>%10.2)=&gt;10.200000</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'price %.1f'</span>%10.2) =&gt; 10.2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'prince %.1f'</span>%10.58) = &gt;10.6 当取一位小数位的时候，将小数位第二位进行舍入操作，但是Python的中间值不是5，导致当小数位第二位是5时，直接被舍去</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'%5.1f'</span>%10.3) =&gt; 10.3</span><br><span class="line">输出一个宽度为5的单位，其中整数3位，小数部分1位，小数点占一位。</span><br><span class="line"></span><br><span class="line">格式化输出：在Python3.0之后，推荐使用&#123;0&#125;来代替前期的%d,%s,%f等一系列的格式化参数，采用了字符串的format函数进行处理。</span><br><span class="line">    写法如下： <span class="built_in">print</span>(<span class="string">'welcome &#123;0&#125;同学，加入&#123;1&#125;班级'</span>.format(<span class="string">'tom'</span>,<span class="string">'Python3班'</span>))</span><br><span class="line">            其中&#123;0&#125;，&#123;1&#125;分别映射format()中的<span class="string">'tom'</span>和<span class="string">'Python3班'</span>，如果前面占位符中的索引值变化，那么他们映射的值也随之变化</span><br></pre></td></tr></table></figure>
<!-- More info: [Server](https://hexo.io/docs/server.html) -->

<h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">变量，我们认为其内容是临时结果，可变的供后续的程序代码进行调用。</span><br><span class="line">（1）变量的声明：在Python没有变量类型，直接进行变量的声明，比如：i = 10</span><br><span class="line"></span><br><span class="line">（2)变量的赋值：在python中，有两种赋值方式</span><br><span class="line">第一种，单个变量赋值  name = <span class="string">'tom'</span></span><br><span class="line">第二种，多个变量同时赋值  name, age, sex = <span class="string">'tom'</span>， 23， <span class="string">'男'</span></span><br><span class="line"></span><br><span class="line">（3）变量的定义规则</span><br><span class="line">推荐定义方式：“驼峰体”：useName=<span class="string">'lcp'</span></span><br><span class="line">               “下滑线”：use_name=<span class="string">'lcp'</span></span><br><span class="line">    1）变量名只能由字母、数字、下划线组成，不能有其他符号出现；</span><br><span class="line">    2）变量名开头不能是数字,可以是字母或下划线；</span><br><span class="line">    3）Python中的关键字不能声明为变量名。常用的关键字例如：<span class="keyword">if</span>、<span class="keyword">for</span>、is、none等等。</span><br><span class="line">    4）名字不能出现分隔符、运算符；</span><br><span class="line">    5）名字长度不限；最好不要太长两个单词最好。</span><br><span class="line">    6）Python是严格区分大小写的语言。A=10和a=10是两个不同的变量。</span><br><span class="line">注释： 不能使用Python预定义标识符名对自定义标识符进行定义。</span><br><span class="line">       尽量避免将下划线作为变量名的开头或结尾。</span><br><span class="line"></span><br><span class="line">（4）变量在内存中的存在情况</span><br><span class="line">    1）python中的变量，在声明和赋值时，不仅声明了变量的名字同时还为这个变量指向了内存中的地址，该地址用来存储变量的值。</span><br><span class="line">    2）python中整数、字符串、浮点数等其本身都属于常量，所以当赋值给一个变量时，如：i = 10意味着将10这个常量在内存中的地址指向，因此，i = 10 ，j = 10 使用id(i),id(j）我们法向他们的id是相同的。因为，他们的值10在内存中的地址时相同的。</span><br><span class="line">    3)变量与内存地址</span><br><span class="line">    当我们声明一个变量时，对其进行赋值实际上就是将变量值所在的内存地址赋值给该变量，也就是说这变量指向其值所在的内存地址。当我们改变变量的值的时候，说白了就是将变量指向的的内存地址进行变化。</span><br><span class="line"></span><br><span class="line">（5）变量与常量</span><br><span class="line">    变量：我们认为其内容是临时结果，可变的。供后续的程序代码进行调用。</span><br><span class="line">    常量：我们认为其内容是不变的，或者在程序运行的过程中也不发生改变。</span><br><span class="line">    在Python中，我们通过大写变量名，来表明这是一个常量，比如：CARDID = <span class="string">'12048377293'</span></span><br></pre></td></tr></table></figure>


<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主要常用：整型和字符串类型。</span><br><span class="line">    Python3数据类型主要包括以下几种：整型、浮点型(只有<span class="built_in">float</span>)、布尔型(Ture or False和1 or 2)、 复数型、字符串型。</span><br></pre></td></tr></table></figure>


<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）在Python中整数类型被指定为int类型。默认情况下，整数采用的是十进制。</span><br><span class="line">    二进制以0b领导，八进制以0o领导，十六进制以0x领导。</span><br><span class="line"></span><br><span class="line">（2）数据类型转换：我们根据计算有数据编码格式，可以将整型数据分为：二进制、八进制、十进制、十六进       制。</span><br><span class="line">    进制间转换：</span><br><span class="line">    二进制转十进制： </span><br><span class="line">                    bin（int）=&gt;将十进制转为二进制      </span><br><span class="line">                    int（bin）=&gt;将二进制转为十进制</span><br><span class="line">    八进制转十进制：  </span><br><span class="line">                    oct（int）=&gt;将十进制转为八进制      </span><br><span class="line">                    int（oct）=&gt;将八进制转为十进制</span><br><span class="line">    十六进制转十进制：</span><br><span class="line">                    hex（int）=&gt;将十进制转为十六进制    </span><br><span class="line">                    int（hex）=&gt;将十六进制转为十进制</span><br><span class="line"></span><br><span class="line">（3）运算符</span><br><span class="line">    算术运算符：+、-、*、/。</span><br><span class="line">    在Python中默认数据类型为浮点型。</span><br><span class="line">    %（求余）、//（相除取整）、int（5/2）相当于“//”、**（幂次方）</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">（1）对于数值运算的四舍五入操作</span><br><span class="line">   math中的floor()和ceil()函数</span><br><span class="line">   import math</span><br><span class="line">   math.floor(3/2)=&gt;1  等同于3//2，只舍不入。</span><br><span class="line">   math.ceil(3/2)=&gt;2   只要有小数部分就进位，只入不舍。</span><br><span class="line">   round（）函数进行四舍五入运算       round（数值【.保留小数位数】）</span><br><span class="line">   round（1.5）=&gt;2   round(1.4)=&gt;1    round(1.4,1)=&gt;1.4</span><br><span class="line">（2）求幂运算</span><br><span class="line">   pow(2,3)=&gt;8  等同于2**3</span><br><span class="line">（3）求绝对值</span><br><span class="line">   abs(-10)=&gt;10</span><br><span class="line">（4）求两数相除的商与余数</span><br><span class="line">   divmod(5,3)=&gt;(1,2) 类似5%3</span><br><span class="line">（5）运算符</span><br><span class="line">   i=10</span><br><span class="line">   i=i+5  等同于  i+=5</span><br><span class="line">   i=i-5  等同于  i-=5</span><br><span class="line">   i=i*5  等同于  i*=5</span><br><span class="line">   i=i/5  等同于  i/=5</span><br><span class="line">   i=i//5  等同于  i//=5</span><br><span class="line">   i=i**2  等同于  i**=2</span><br><span class="line">   i=i%3   等同于  i%=3</span><br></pre></td></tr></table></figure>

<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）python中布尔型分Ture和False两张，但是在实际操作中我们可以将它与0和1等同。</span><br><span class="line"></span><br><span class="line">（2）布尔型常用在逻辑运算和判断条件中，作为结果来使用，但是也可以参与算术运算，当进行算术运算时，       Ture做为1，False作为0参与运算。</span><br><span class="line"></span><br><span class="line">（3）a=Ture     a+1=&gt;2</span><br><span class="line">    b=False    b+1=&gt;1</span><br><span class="line">    a+b=&gt;1</span><br><span class="line">注意：通常我们在python，不能将布尔型参与算术运算的。布尔型一般参加比较运算或逻辑运算，其返回值还是      布尔型。</span><br><span class="line"></span><br><span class="line">（4）布尔型求非： not</span><br><span class="line">    not a =&gt; False</span><br><span class="line">    not b =&gt; True</span><br><span class="line"></span><br><span class="line">（5）精确的十进制</span><br><span class="line">    在python中，我们通过阅读官方文档了解到，浮点数是一种近似值的表示，因此直接是使用浮点数时常常出现精确  丢失或不匹配的情况。</span><br><span class="line">    python中提出了Decimal对象来进行解决，通过引入 import decimal生成一个decimal对象，将浮点数转换为 decimal类型，可以支持完成对应的算术运算。</span><br><span class="line">    例如：</span><br><span class="line">        from decimal import Decimal   <span class="comment"># 引入decimal包中的Deciaml对象</span></span><br><span class="line">        f1 = 12.4556</span><br><span class="line">        f2 = 24.3</span><br><span class="line">        c = Decimal.from_float(f1)    <span class="comment"># 将浮点数转换为decimal对象   </span></span><br><span class="line">        a = Decimal(f1).quantize(Decimal(<span class="string">'0.00'</span>)) <span class="comment">#将浮点数转换为decimal对象，同时指定该数值                                           的精度，保留小数点后两位，并自动完成四舍五入</span></span><br><span class="line">        b = Decimal(f2).quantize(Decimal(<span class="string">'0.00'</span>))</span><br><span class="line">        <span class="built_in">print</span>((a*b).quantize(Decimal(<span class="string">'0.00'</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、字符串声明，可以使用<span class="string">''</span>也可以使用<span class="string">""</span>，他们都可以表示字符串内容。</span><br><span class="line"></span><br><span class="line">2、比较运算符：&gt;、&lt;、==、!=、&gt;=、&lt;=</span><br><span class="line">他们的返回值为布尔型，即True或False</span><br><span class="line">字符串进行比较时，采用对应位置的逐字母进行比较，首先将字母转成ASCII码，然后根据码值进行比较大小。如果一旦出现一方的字母码值大于另一方，就结束比较。</span><br><span class="line">提示：在键盘上，所有的字符的ASCII码值都小于a,b,c.....这些字母的码值</span><br><span class="line">只有这四个字符的ASCII码值大于字母z的码值：<span class="string">'&#123;'</span>、<span class="string">'|'</span>、<span class="string">'&#125;'</span>、<span class="string">'~'</span>，它们的码值从123-126</span><br><span class="line"></span><br><span class="line">3、我们使用input()，允许进行交互式输入，默认input()输入的值类型为str字符串类型。</span><br><span class="line"></span><br><span class="line">4、字符串常用的方法</span><br><span class="line">1）find() 查找</span><br><span class="line">函数格式：str.find(子字符串[,开始索引位，结束索引位])</span><br><span class="line">返回值：如果查找成功，则返回所查找内容在字符串中的索引位置，如果没有找到，返回-1.</span><br><span class="line">注意：如果所查找的内容中，有多个相同的字母，只会返回第一个字母所在的索引位。</span><br><span class="line">举例：</span><br><span class="line">    str1 = <span class="string">'hello'</span></span><br><span class="line">    str1.find(<span class="string">'ll'</span>)</span><br><span class="line">  =&gt;2  </span><br><span class="line">该例中，<span class="string">'ll'</span>在字符串中出现了两次，但只会返回第一次出现的索引位置。</span><br><span class="line">为什么查找时，没有找到目标字符串的情况下会返回-1。其实，在find操作中，会对字符串进行扫描从字符串的索引位0开始，一直到字符串结尾，如果在字符串最后一位没有找到匹配的内容，将指向字符串结束符(EOF)，该结束符为-1。所以找不到时，find返回值为-1.</span><br><span class="line">更多用法：</span><br><span class="line">    string1 = <span class="string">'apple,banana,apple,apple'</span></span><br><span class="line">    string1.find(<span class="string">'apple'</span>)</span><br><span class="line">  =&gt;0</span><br><span class="line">    string1.find(<span class="string">'apple'</span>,5)</span><br><span class="line">  =&gt;13</span><br><span class="line">    string1.find(<span class="string">'apple'</span>,7,20)</span><br><span class="line">  =&gt;13</span><br><span class="line">    string1.find(<span class="string">'apple'</span>,14,20)</span><br><span class="line">  =&gt;-1</span><br><span class="line">    string1.find(<span class="string">'apple'</span>,14,24)</span><br><span class="line">  =&gt;19</span><br><span class="line"></span><br><span class="line">对比：</span><br><span class="line">1）index() 返回指定字符的索引位</span><br><span class="line">函数格式：index(子字符串[,开始索引位，结束索引位])</span><br><span class="line">返回值：如果找到指定的字符串，则返回其索引位；如果找不到就报错ValueError</span><br><span class="line"></span><br><span class="line">find()与index()函数的区别</span><br><span class="line">第一，两者在执行结果时类似的，如果找到指定的字符就会返回其索引位</span><br><span class="line">第二，find()如果找不到指定的字符时，返回-1；而index()找不到指定的字符，raise ValueError.</span><br><span class="line">第三，从效率上来讲，index的查询速度要优于find,因为在python中对于像字符串这样的有序数据类型，会产生一个索引对象来自动维护其序列，find()函数不管是否有这样的序列，都需要在字符串本身进行逐一查找，而index()会通过这个索引对象的映射方式，来快速找到对应的索引位。</span><br><span class="line"></span><br><span class="line">2）split() 拆分字符串</span><br><span class="line">函数格式：str.split([分隔符])</span><br><span class="line">返回值：根据指定的分隔符，对字符串进行拆分，返回一个列表；如果不指定分隔符，那么会将整个字符串，作为列表的一个元素。</span><br><span class="line">举例：</span><br><span class="line">    string1 = <span class="string">'tv,pc,notebook,phone'</span></span><br><span class="line">    <span class="built_in">print</span>(string1.split(<span class="string">','</span>))</span><br><span class="line">  =&gt;[<span class="string">'tv'</span>, <span class="string">'pc'</span>, <span class="string">'notebook'</span>, <span class="string">'phone'</span>]</span><br><span class="line">    <span class="built_in">print</span>(string1.split())</span><br><span class="line">  =&gt;[<span class="string">'tv,pc,notebook,phone'</span>]</span><br><span class="line">注意：split中的分隔符，我们根据字符串中的实际情况而定。如果使用了不正确的分隔符，str.split(<span class="string">'错误分隔符'</span>)操作结果str.split(),会将整个字符串作为列表的一个元素。</span><br><span class="line"></span><br><span class="line">3）strip() 字符串左右两端去除指定字符（默认情况，去除空格）</span><br><span class="line">函数格式：str.strip([指定字符])</span><br><span class="line"> 返回值：根据指定的字符，对字符串进行两端去除其内容，返回一个新的字符串。如果字符串中间有空格或指定字符，那么该函数不起作用。如果指定的字符在字符串左右两端不存在，那么将返回字符串本身。</span><br><span class="line">举例：</span><br><span class="line">缺省情况</span><br><span class="line">    string1 = <span class="string">'  hello world  '</span></span><br><span class="line">    string1.strip()</span><br><span class="line">    <span class="built_in">print</span>(string1)</span><br><span class="line">  =&gt;hello world  </span><br><span class="line"></span><br><span class="line">指定字符</span><br><span class="line">    string1 = <span class="string">'awelcom to zhengzhoua'</span></span><br><span class="line">    string1.strip(<span class="string">'a'</span>)</span><br><span class="line">    <span class="built_in">print</span>(string1)</span><br><span class="line">  =&gt;<span class="string">'welcom to zhengzhou'</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    1）字符串类型，一旦被声明赋值后，其内容是不可被改变的，如果需要改变原字符串变量的值，必须对其进行重新赋值。</span><br><span class="line">    2）如果指定字符内容为一个字符序列，那么意味着使用strip去除左右两端指定字符时，只要符合字符序列中的某一位，就进行去除。</span><br><span class="line">举例：</span><br><span class="line">    string1 = <span class="string">' awelcom to zhengzhouab'</span></span><br><span class="line">    string1.strip(<span class="string">' ab'</span>)</span><br><span class="line">    <span class="built_in">print</span>(string1)</span><br><span class="line">  =&gt;<span class="string">'welcom to zhengzhou'</span></span><br><span class="line"></span><br><span class="line">4）replace()替换函数</span><br><span class="line">函数格式：str.replace(old,new[,max])</span><br><span class="line">返回值：将指定字符串（old）替换为新字符串（new）,最大可以替换max次。替换完成后，返回一个新字符串。</span><br><span class="line">注意：此处的max参数，主要用来指定替换的次数，如果该参数缺省，表示替换里面所有符合条件的字符串。</span><br><span class="line">举例：</span><br><span class="line">    string1 = <span class="string">'honor,oppo,vivo,apple,oppo,oppo'</span></span><br><span class="line">    old_str = <span class="string">'oppo'</span></span><br><span class="line">    new_str = <span class="string">'xiaomi'</span></span><br><span class="line">    string1.replace(old_str, new_str)     <span class="comment"># 替换所有的oppo</span></span><br><span class="line">  =&gt;<span class="string">'honor,xiaomi,vivo,apple,xiaomi,xiaomi'</span></span><br><span class="line">    string1.replace(old_str, new_str,2)   <span class="comment">#替换指定次数，即两处oppo</span></span><br><span class="line">  =&gt;<span class="string">'honor,xiaomi,vivo,apple,xiaomi,oppo'</span></span><br><span class="line"></span><br><span class="line">5）isalnum()、isalpha()、isdigit()</span><br><span class="line">函数格式：str.isalnum()    判断字符串内容，是否有数字或字母组成</span><br><span class="line">          str.isalpha()    判断字符串内容，是否由字母组成</span><br><span class="line">          str.isdigit()    判断字符串内容，是否由数字组成</span><br><span class="line">返回值：如果符合条件，返回True；如果不符合，返回False。</span><br><span class="line"></span><br><span class="line">6）[] 字符串运算符</span><br><span class="line">使用方法：str[索引位] =&gt; 返回指定索引位的字符，</span><br><span class="line">索引位有两种表示方式：</span><br><span class="line">string1 = hello world</span><br><span class="line">第一种：string1[0] =&gt; h    到string1[10] =&gt; d</span><br><span class="line">第二种：string1[-1] =&gt; d   到string1[-11] =&gt; h</span><br><span class="line">切片操作:</span><br><span class="line">格式：str[start,end,step]</span><br><span class="line">start：代表切片开始的索引位</span><br><span class="line">end: 代表切片结束的索引位（但是不会输出该索引位指向的字符）</span><br><span class="line">step：代表每隔次几个字符个数截取一个</span><br><span class="line">举例：</span><br><span class="line">    string1 = hello world</span><br><span class="line">    string1[0:3]   <span class="comment">#从索引位为0的字符开始，到索引位3结束，但不包括索引位3所指向的字符。</span></span><br><span class="line">  =&gt;hel  </span><br><span class="line">    string1[2:4] </span><br><span class="line">  =&gt;ll</span><br><span class="line">    string1[0:-1] </span><br><span class="line">  =&gt;hello worl </span><br><span class="line">    string1[0:8:2] </span><br><span class="line">  =&gt;hlow</span><br><span class="line"></span><br><span class="line">    str1[:]   <span class="comment">#等于将字符串进行复制</span></span><br><span class="line">  =&gt;<span class="string">'hello world'</span>  </span><br><span class="line">    str1[:5]  <span class="comment">#如果没有标明开始索引位，默认从0开始</span></span><br><span class="line">  =&gt;<span class="string">'hello'</span></span><br><span class="line">    str1[::]  <span class="comment">#等同于str1[:]</span></span><br><span class="line">  =&gt;<span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">使用步长，实现字符串反转</span><br><span class="line">    string1[-1::-1]  </span><br><span class="line">  =&gt;dlrow olleh    <span class="comment">#从索引位-1开始，一直到字符串结束，反向输出字符</span></span><br><span class="line">但是下列操作，会返回一个空字符串：</span><br><span class="line">    string1[-1:4]  </span><br><span class="line">  =&gt; <span class="string">''</span></span><br><span class="line">    string1[-1:-5] </span><br><span class="line">  =&gt; <span class="string">''</span></span><br><span class="line"></span><br><span class="line">7）连接符与重复操作符</span><br><span class="line">+：在字符串中使用时，作为连接两个字符串，并返回一个新字符串的作用来使用。</span><br><span class="line">*：重复操作指定的次数，即将字符串重复输出N次。返回一个新字符串。</span><br><span class="line">注意：在重复操作中，必须遵循：字符串*正整数这样的格式，如果数值不是正整数，其结果返回一个空字符串，如果不是数值类型，程序报错。</span><br><span class="line">8）<span class="keyword">in</span>运算符</span><br><span class="line">用来检测指定的内容，是否在字符串中，如果存在则返回True，反之返回False</span><br><span class="line">举例:</span><br><span class="line">    string1 = <span class="string">'hello world'</span></span><br><span class="line">    substr = <span class="string">'e'</span></span><br><span class="line">    substr <span class="keyword">in</span> string1</span><br><span class="line">  =&gt;True</span><br><span class="line">    substr = <span class="string">'ll'</span></span><br><span class="line">    substr <span class="keyword">in</span> string1</span><br><span class="line">  =&gt;True</span><br><span class="line">    substr = <span class="string">'wr'</span></span><br><span class="line">    substr <span class="keyword">in</span> string1</span><br><span class="line">  =&gt;False</span><br></pre></td></tr></table></figure>

<!-- More info: [Deployment](https://hexo.io/docs/deployment.html) -->

<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）条件语句</span><br><span class="line">单判断：</span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">   代码</span><br><span class="line">双分支：</span><br><span class="line"><span class="keyword">if</span> 条件：</span><br><span class="line">   代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   代码</span><br><span class="line">多分支：</span><br><span class="line"><span class="keyword">if</span> 条件：</span><br><span class="line">   代码</span><br><span class="line"><span class="keyword">elif</span> 条件：</span><br><span class="line">   代码</span><br><span class="line"><span class="keyword">elif</span> 条件：</span><br><span class="line">   代码</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   代码</span><br><span class="line"></span><br><span class="line">2）逻辑运算符： and、or、not</span><br><span class="line">and:左右两端都是布尔型，其结果也为布尔型。当左右两端的值都为True，其结果才为True，有一方为False，其结果一定为False。</span><br><span class="line">or:左右两端都是布尔型，其结果也为布尔型。当左右两端的值有一方为True时，其结果就为True，只有在双方都为False时，其结果才为False。</span><br><span class="line">not：属于单目运算，其结果也是布尔型。其作用就是求反，如果变量为True，结果为False，如果为False，其结果为True。</span><br><span class="line">逻辑运算、比较运算常用在条件中使用。同时，这两种运算符经常配合使用。</span><br></pre></td></tr></table></figure>

<h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3）循环控制语句</span><br><span class="line"><span class="keyword">for</span>循环</span><br><span class="line">第一种：（推荐）</span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合：</span><br><span class="line">    (代码)</span><br><span class="line">说明：这种循环方式，我们称为快速迭代循环，能够对集合数据进行遍历。</span><br><span class="line">注意：这种方式只能用在集合数据上，比如：字符串、列表、元组、字典等内容。</span><br><span class="line">例如：</span><br><span class="line">string1 = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> string1:</span><br><span class="line">	<span class="built_in">print</span>(item)</span><br><span class="line">  =&gt;h</span><br><span class="line">    e</span><br><span class="line">    l</span><br><span class="line">    l</span><br><span class="line">    o</span><br><span class="line"></span><br><span class="line">    w</span><br><span class="line">    o</span><br><span class="line">    r</span><br><span class="line">    l</span><br><span class="line">    d</span><br><span class="line">第二种：传统式，配合range()函数使用。通过range()函数指定了循环的范围。</span><br><span class="line"><span class="keyword">for</span> i range(循环次数):</span><br><span class="line">    代码</span><br><span class="line"></span><br><span class="line">说明：这种循环方式，采用指定循环次数，对目标集合进行遍历。其做法主要是让循环与集合的下标同步，在循环次数时一同取出集合指定下标的对应值。</span><br><span class="line">range()函数：</span><br><span class="line">函数格式：</span><br><span class="line">range(stop) :缺省情况下，表示从0开始，循环n次</span><br><span class="line">range(star,stop[,step])</span><br><span class="line">其中，star：循环开始的值，stop：循环次数，step：循环步长。注意此处循环，会根据stop中的值循环规定的次数，但是显示时会从start位置开始。</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(3,10):</span><br><span class="line">	<span class="built_in">print</span>(i,end=<span class="string">' '</span>)</span><br><span class="line">=&gt;3 4 5 6 7 8 9 </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(5,10):</span><br><span class="line">	<span class="built_in">print</span>(i,end=<span class="string">' '</span>)</span><br><span class="line">=&gt;5 6 7 8 9 </span><br><span class="line">range(1,10)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环的常用方式：嵌套</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(次数):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(次数):</span><br><span class="line">    </span><br><span class="line">注意：在这种嵌套表示的过程中，变量的位置尤为重要，通用原则为：如果变量的值需要通过外层循环来获取或生成，那么我们可以将其设为全局变量，即与外层循环<span class="keyword">for</span>同等级的变量，如果变量需要在内层循环中生成或获取，我们通常会在外循环中声明，即与内循环同级。</span><br><span class="line"><span class="keyword">while</span>循环</span><br><span class="line">格式：<span class="keyword">while</span> 条件：</span><br><span class="line">           代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span>与<span class="built_in">continue</span></span><br><span class="line"><span class="built_in">break</span>：当满足指定条件时，<span class="built_in">break</span>表示中断（中止）此循环，如果循环外部还有其他代码则继续向下执行。</span><br><span class="line"><span class="built_in">continue</span>：当满足指定条件时，<span class="built_in">continue</span>表示结束本次循环，开始下一次循环。注意<span class="built_in">continue</span>并没有退出循环。</span><br><span class="line">同时，这两个关键字都是必须配合循环语句来使用，不能单独用在其他地方。</span><br></pre></td></tr></table></figure>

<h3 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h3><h4 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）概念：List数据，首先它可以存储各种数据类型，比如：数值、字符串、布尔型等等；其次，列表中的元素可以随时进行删除、修改、增加，其长度随之变化；同时，列表也是有序的，我们同样可以使用循环对其进行遍历。</span><br><span class="line"></span><br><span class="line">（2）列表的声明与赋值</span><br><span class="line">    1）声明列表同时进行赋值</span><br><span class="line">        list1 = [1,2,3,4,5]</span><br><span class="line">        list2 = [<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>,<span class="string">'five'</span>]</span><br><span class="line">        list3 = [1,<span class="string">'two'</span>,3,<span class="string">'four'</span>,5]</span><br><span class="line">    2)声明一个空列表，后续进行添加元素</span><br><span class="line">        list4 = []  此时，python会生成一个空列表,即：[]</span><br><span class="line">        注意，生成的这个空列表中没有任何值，它的长度为0</span><br><span class="line">我们通过观察，可以发现列表是有序的。那么通过<span class="keyword">for</span>  <span class="keyword">in</span>  方式可以对其进行快速遍历</span><br><span class="line">比如：</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list1:</span><br><span class="line">        <span class="built_in">print</span>(item,end=<span class="string">' '</span>)</span><br><span class="line">    1 2 3 4 5</span><br><span class="line">    </span><br><span class="line">（3）列表的操作</span><br><span class="line">    1）增加元素</span><br><span class="line">    第一种：使用append()函数，在列表的尾部追加一个新元素</span><br><span class="line">        函数格式：list.append(元素)</span><br><span class="line">        返回值：列表长度+1</span><br><span class="line">        举例:</span><br><span class="line">            list1 = [1,2,3,4,5]</span><br><span class="line">            list1.append(6)</span><br><span class="line">            <span class="built_in">print</span>(list1)</span><br><span class="line">          =&gt;[1,2,3,4,5,6]</span><br><span class="line">        注意：该方法添加元素都是在列表的尾部。</span><br><span class="line">    第二种：使用extend()函数，在列表尾部追加一个子列表内容。</span><br><span class="line">        函数格式：list.extend(子列表)</span><br><span class="line">        返回值：列表长度+1</span><br><span class="line">        举例:list1 = [1,2,3,4,5]</span><br><span class="line">            sublist = [6,7,8]</span><br><span class="line">            list1.extend(sublist)</span><br><span class="line">            <span class="built_in">print</span>(list1)</span><br><span class="line">          =&gt;[1,2,3,4,5,6,7,8]</span><br><span class="line">    第三种：使用“+”运算符，连接两个列表，其结果生成一个新的列表。同时两个列表不变。</span><br><span class="line">        举例:list1 = [1,2,3]</span><br><span class="line">            list2 = [4,5,6]</span><br><span class="line">            list3 = list1 + list2</span><br><span class="line">            <span class="built_in">print</span>(list3)</span><br><span class="line">          =&gt;[1,2,3,4,5,6]</span><br><span class="line">    第四种：使用insert()函数，对列表指定位置进行插入操作。</span><br><span class="line">        函数格式：list.insert(idx,元素)，其中idx代表要插入的索引位。</span><br><span class="line">        返回值：列表长度+1</span><br><span class="line">        举例:</span><br><span class="line">            list1 = [1,2,3,4,5,6,7]</span><br><span class="line">            list1.insert(4,<span class="string">'four'</span>)</span><br><span class="line">            <span class="built_in">print</span>(list1)</span><br><span class="line">          =&gt;[1,2,3,4,<span class="string">'four'</span>,5,6,7]</span><br><span class="line">        注意：插入指定的索引位后，该索引位之后的元素下标+1。</span><br><span class="line">    我们实际使用的时候，通常会利用append()或extend()来实现元素的追加，而少用insert()进行元素的插入。因为在频繁的插入操作，需要耗费大量的内存来维护列表的索引关系。</span><br><span class="line">    2）修改元素</span><br><span class="line">        通过索引位，找到指定的列表元素，重新对其进行赋值即可完成修改操作。</span><br><span class="line">        举例:</span><br><span class="line">            list1 = [1,2,3,4]</span><br><span class="line">            list1[2] = 5</span><br><span class="line">            <span class="built_in">print</span>(list1)</span><br><span class="line">          =&gt;[1,2,5,4]</span><br><span class="line">    3）删除元素</span><br><span class="line">    第一种：使用remove()函数移除在列表中指定元素。</span><br><span class="line">        函数格式：list.remove(元素)</span><br><span class="line">        返回值：移除后列表长度-1 </span><br><span class="line">        举例:</span><br><span class="line">            list1 = [1,2,3,4,5]</span><br><span class="line">            list1.remove(3)</span><br><span class="line">            <span class="built_in">print</span>(list1)</span><br><span class="line">          =&gt;[1,2,4,5]</span><br><span class="line">    第二种：使用pop()函数       </span><br><span class="line">          默认情况下函数格式：list.pop()   作用为从列表尾部弹出一个元素</span><br><span class="line">                     返回值：返回弹出的元素本身，如果列表已经为空，执行pop()函数会报错</span><br><span class="line">                     举例:</span><br><span class="line">                        list1 = [1,2,3,4,5]</span><br><span class="line">                        list1.pop()</span><br><span class="line">                      =&gt;5 </span><br><span class="line">                        list1 = []</span><br><span class="line">                        list1.pop()</span><br><span class="line">                      =&gt;IndexError: pop from empty lis（报错）  </span><br><span class="line">          liist.pop(idx):参数idx为索引位，作用为弹出该索引位下的元素</span><br><span class="line">          返回值：返回弹出的元素本身，如果列表已经为空，执行pop()函数会报错</span><br><span class="line">          举例:</span><br><span class="line">              list1 = [1,2,3,4,5]</span><br><span class="line">              list1.pop()</span><br><span class="line">            =&gt;5 </span><br><span class="line">              list1 = []</span><br><span class="line">              list1.pop()</span><br><span class="line">  此时pop()函数和remove()类似，只不过pop()会返回弹出的值而remove()不会返回被删除的值。</span><br><span class="line">    第三种：使用del删除指定的列表片段或列表本身</span><br><span class="line">          del list[idx]        删除列表该索引位下的元素</span><br><span class="line">          del list             删除整个列表，并释放该列表的内存空间</span><br><span class="line">          del list[start:end]  删除该列表的该片段</span><br><span class="line">          举例：</span><br><span class="line">              list1=[1,2,3,4,5,6,7,8]</span><br><span class="line">              del list1[2]</span><br><span class="line">              <span class="built_in">print</span>(list1)</span><br><span class="line">            =&gt;[1,2,4,5,6,7,8]</span><br><span class="line">              list1=[1,2,3,4,5,6,7,8]</span><br><span class="line">              del list1</span><br><span class="line">              <span class="built_in">print</span>(list1)</span><br><span class="line">            =&gt;报错，因为释放了list1的内存空间，list1就不存在了</span><br><span class="line">              list1=[1,2,3,4,5,6,7,8]</span><br><span class="line">              del list1[0:3]</span><br><span class="line">              <span class="built_in">print</span>(list1)</span><br><span class="line">            =&gt;[4,5,6,7,8]</span><br><span class="line">    补充：del与clear()的区别</span><br><span class="line">          del list VS list.clear()</span><br><span class="line">        （1）del 可以将列表的内容进行删除，同时将列表所占内存进行释放。</span><br><span class="line">        （2）clear()只是将列表中的内容进行清空，原列表内容为空。        </span><br><span class="line"></span><br><span class="line">        +与*运算符</span><br><span class="line">        在列表中我们使用+运算符，可以将两个列表进行连接，生成一个新的列表。</span><br><span class="line">        比如：list1 = [1,2,3]  list2 = [4,5,6]  list1+list2=&gt;[1,2,3,4,5,6]</span><br><span class="line">        使用*运算符，可以将目标列表的内容重复N次，并生成一个新的列表。</span><br><span class="line">        比如：list1 = [1,2,3] list1*2=&gt;[1,2,3,1,2,3]    </span><br><span class="line">        </span><br><span class="line">        max()与min()</span><br><span class="line">        函数格式：max(list)、min(list)</span><br><span class="line">        返回值：返回该列表中最大值或最小值。</span><br><span class="line">        注意：该函数在使用时，必须要求所统计的列表中元素的数据类型要一致。不支持多数据类型，数值型根据数值本身大小取值，字符串类型根据字母的ASCII码值取值，布尔值根据对应的1、0取值。</span><br><span class="line"></span><br><span class="line">        sum()</span><br><span class="line">        函数格式：sum(list)</span><br><span class="line">        返回值：将列表中所用的数值进行求和运算，返回结果。注意，该函数只能用于数值型列表。</span><br><span class="line">        sort()排序</span><br><span class="line">        函数格式：list.sort()、list.sort(reverse=True)</span><br><span class="line">        返回值：默认情况下，将原列表中元素按照升序进行排序,</span><br><span class="line">        如果设置了反转参数为True，那么将原列表中的元素按照降序排列</span><br><span class="line"></span><br><span class="line">        sorted()排序</span><br><span class="line">        函数格式：sorted(list)、sorted(list,reverse=True)</span><br><span class="line">        返回值：默认情况下，将原列表中元素按照升序进行排序,</span><br><span class="line">        如果设置了反转参数为True，那么将原列表中的元素按照降序排列</span><br><span class="line">        注意：上面两种排序函数，其中第一个属于列表自身的排序方法，而第二种属于python内置的排序方法，也就是说第二种可以应用在包括列表在内多种集合排序。</span><br><span class="line"></span><br><span class="line">        count()计数函数</span><br><span class="line">        函数格式：list.count(元素)</span><br><span class="line">        返回值：返回指定元素在列表中出现的次数</span><br><span class="line"></span><br><span class="line">        <span class="keyword">in</span> 关键字</span><br><span class="line">        判断指定的元素是否在列表中存在，如果存在返回True，否在返回False</span><br><span class="line"></span><br><span class="line">        index()检索函数</span><br><span class="line">        函数格式：list.index(元素)</span><br><span class="line">        返回值：返回该元素在列表中的索引位置，如果不存在报错。</span><br><span class="line"></span><br><span class="line">（4）常用数据类型的转换</span><br><span class="line">  字符串转为整型：int(str)</span><br><span class="line">  函数格式：int(str)</span><br><span class="line">  返回值：将字符型数值转为整数</span><br><span class="line">  int(<span class="string">'3'</span>) =&gt; 3</span><br><span class="line">  字符串转为浮点型:<span class="built_in">float</span>(str)</span><br><span class="line">  函数格式：<span class="built_in">float</span>(str)</span><br><span class="line">  返回值：将字符型浮点数转为浮点数</span><br><span class="line">  <span class="built_in">float</span>(<span class="string">'2.4'</span>) =&gt; 2.4</span><br><span class="line">  数值转为字符串：str(int)、str(<span class="built_in">float</span>)</span><br><span class="line">  函数格式：str(int)、str(<span class="built_in">float</span>)</span><br><span class="line">  返回值：将整数或浮点数，转为字符型数值</span><br><span class="line">  str(2) =&gt; <span class="string">'2 '</span>    str(2.4) =&gt; <span class="string">'2.4'</span></span><br><span class="line">  字符串转为列表：list(str)</span><br><span class="line">  函数格式：list(str)</span><br><span class="line">  返回值：将指定的字符串，按照元素顺序逐一转为列表</span><br><span class="line">  string1 = <span class="string">'hello world'</span></span><br><span class="line">  list1 = list(string1)</span><br><span class="line"></span><br><span class="line">（5）列表比较运算符操作</span><br><span class="line">  相当于列表使用普通的比较运算符</span><br><span class="line">  import operator</span><br><span class="line">  operator.ge()         大于等于   &gt;=</span><br><span class="line">  operator.gt()         大于       &gt;</span><br><span class="line">  operator.eq()       等于         ==</span><br><span class="line">  operator.ne()        不等于      !=</span><br><span class="line">  operator.le()           小于等于 &lt;=</span><br><span class="line">  operator.lt()          小于      &lt;</span><br><span class="line">  格式：operator.ge(列表1,列表2)</span><br><span class="line">  返回值：如果符合条件，返回True，反之，返回False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">' '</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>]</span><br><span class="line">  拆分字符串：str.split(分隔符)</span><br><span class="line">  函数格式：str.split(分隔符)</span><br><span class="line">  返回值：将字符串，根据指定的分隔符，转换为列表</span><br><span class="line">  string1 = <span class="string">"锅包肉 肠粉 毛血旺 宫保鸡丁"</span></span><br><span class="line">  list2 = string1.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">  [<span class="string">'锅包肉'</span>, <span class="string">'肠粉'</span>, <span class="string">'毛血旺'</span>, <span class="string">'宫保鸡丁'</span>]</span><br><span class="line">  列表转为字符串：<span class="string">'分隔符'</span>.join(list)</span><br><span class="line">  函数格式:<span class="string">'分隔符'</span>.join(list)</span><br><span class="line">  返回值：将指定的列表中的元素，通过分隔符进行连接，转换为字符串</span><br><span class="line">  list2 = [<span class="string">'锅包肉'</span>, <span class="string">'肠粉'</span>, <span class="string">'毛血旺'</span>, <span class="string">'宫保鸡丁'</span>]</span><br><span class="line">  <span class="string">' '</span>.join(list2)</span><br><span class="line">  <span class="string">'锅包肉 肠粉 毛血旺 宫保鸡丁'</span></span><br><span class="line"></span><br><span class="line">例题：冒泡排序</span><br><span class="line">    list1 = [80,100,67,1,34,10]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(len(list1)):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(m+1,len(list1)):</span><br><span class="line">            first = list1[m]</span><br><span class="line">            second = list1[n]</span><br><span class="line">            <span class="keyword">if</span> first &lt; second:</span><br><span class="line">                list1[m] = list1[n]</span><br><span class="line">                list1[n] = first</span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>
<h4 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple 元组"></a>Tuple 元组</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)  元组的概念：元组是值的有序序列，里面可以存储各种数据类型的元素。但是元组一旦被赋值后，其内     容就不可被改变。</span><br><span class="line"></span><br><span class="line">2)声明与赋值</span><br><span class="line">  第一种，tup = a,b,c,d</span><br><span class="line">  第二种，tup = (a,b,c,d) 推荐使用该种声明方式。</span><br><span class="line">  第三种，tup = tuple() 声明一个空的元组对象</span><br><span class="line">  注意：元组在赋值时，且元素只有一个时，具体情况如下：</span><br><span class="line">  tuple1 = (1,)或tuple1 = 1,一定要在元素后面加上一个,号，与普通变量赋值进行区分。</span><br><span class="line"></span><br><span class="line">3)常用操作</span><br><span class="line">  +、*、<span class="keyword">in</span>、遍历等等，参考列表。</span><br><span class="line"></span><br><span class="line">4)元组与列表转换</span><br><span class="line">  元组转为列表：</span><br><span class="line">  tuple1 = (1,2,3)</span><br><span class="line">  list1 = list(tuple1)</span><br><span class="line">  列表转为元组</span><br><span class="line">  list1 = [1,2,3]</span><br><span class="line">  tuple1 = tuple(list1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">内容补充:</span><br><span class="line">    在python中，我们认为变量如果被赋值后，使用not运算后，会得False。如果一个变量没有被赋值或设为空值，那么进行not运算时，返回True。比如：</span><br><span class="line">    a = 10</span><br><span class="line">    not a =&gt; False</span><br><span class="line">    a = None (None代表了空值)</span><br><span class="line">    not a =&gt; True</span><br><span class="line">    list1 = list() 此时列表没有被赋值，为空列表</span><br><span class="line">    not list1 =&gt; True</span><br><span class="line">    list1.append(1,2,3)  此时列表进行赋值</span><br><span class="line">    not list1 =&gt; False</span><br></pre></td></tr></table></figure>
<h4 id="dict-字典"><a href="#dict-字典" class="headerlink" title="dict 字典"></a>dict 字典</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、字典类型的基本概念</span><br><span class="line">  字典数据类型，由key&#x3D;value结构构成的。也就是说字典类型中的每个元素都是有两部分构成，中间使用：连接。其中，key和value的可以是任意数据类型的内容。</span><br><span class="line"></span><br><span class="line">2、字典对象的生成</span><br><span class="line">  第一种、dic &#x3D; &#123;1:&#39;one&#39;,2:&#39;two&#39;,3:&#39;three&#39;&#125;，两边使用一对&#123;&#125;来界定。</span><br><span class="line">  第二种、dic &#x3D; dict() 生成一个空字典。</span><br><span class="line">  第三种、dic &#x3D; dict(&#123;1:&#39;one&#39;,2:&#39;two&#39;,3:&#39;three&#39;&#125;)</span><br><span class="line">  第四种、使用zip()函数生成字典</span><br><span class="line">          函数格式：zip(iter1,iter2,....)</span><br><span class="line">          返回值：返回一个zip对象</span><br><span class="line">          我们通过zip函数，指定对应的元组，分别来作为字典的key和 value，生成zip对象转成字典数据。</span><br><span class="line">          例如：</span><br><span class="line">          dict(zip((&#39;id&#39;,&#39;name&#39;,&#39;city&#39;),(1,&#39;hhp&#39;,&#39;zhengzhou&#39;)))</span><br><span class="line">          &#x3D;&gt;&#123;&#39;id&#39;: 1, &#39;name&#39;: &#39;hhp&#39;, &#39;city&#39;: &#39;zhengzhou&#39;&#125;</span><br><span class="line">注意：字典中的key是唯一的，如果在生成时命名了多个同名的key，那么实际上字典会使用最后一次命名的key来覆盖前面的同名内容。</span><br><span class="line">同时，字典在赋值时，允许其value或key为空。</span><br><span class="line"></span><br><span class="line">3、字典的特性</span><br><span class="line">首先、字典中的元素时根据每对键值对中的key来决定的，通过相应的哈希算法来决定他们对应的value的存储地址，因此字典时无序的。</span><br><span class="line">其次，字典中的key，可以是数值、字符串、元组等构成，注意这些内容都是不可改变的。同时，字典中的key都是唯一的。</span><br><span class="line">然后，字典中的value需用通过key来获取。</span><br><span class="line"></span><br><span class="line">4、字典的常用操作</span><br><span class="line">(1)字典的新增和修改</span><br><span class="line">  dic &#x3D; &#123;1:&#39;one&#39;,2:&#39;two&#39;,3:&#39;three&#39;&#125;</span><br><span class="line">  dic[4] &#x3D; &#39;four&#39;</span><br><span class="line">  &#x3D;&gt;&#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;, 4: &#39;four&#39;&#125;</span><br><span class="line">  如果字典中不存在指定的key，则对该字典实现元素的新增</span><br><span class="line">  </span><br><span class="line">  &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;, 4: &#39;four&#39;, 5: &#39;fiv&#39;&#125;</span><br><span class="line">  dic[5] &#x3D; &#39;five&#39;</span><br><span class="line">  &#x3D;&gt;&#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;, 4: &#39;four&#39;, 5: &#39;five&#39;&#125;</span><br><span class="line">  如果字典中存在指定的key，那么对key对应的value进行修改</span><br><span class="line"></span><br><span class="line">(2)字典的删除</span><br><span class="line">  第一种，使用del进行字典内容的删除</span><br><span class="line">  del dic[key]    删除指定可以对应的value内容</span><br><span class="line">  del dic         删除整个字典，并释放其所占内存</span><br><span class="line">  第二种，使用pop()函数，删除指定key对应的value内容</span><br><span class="line">  函数格式：dict.pop(key)  ，其中参数为字典中的key值</span><br><span class="line">  返回值：返回所删除key对应的value内容</span><br><span class="line">  第三种，使用clear()函数，清空字典中所有内容</span><br><span class="line">  函数格式：dict.clear()</span><br><span class="line">  返回值：清空字典内容，返回一个空字典</span><br><span class="line">  第四种：popitem()，删除字典中的键值对</span><br><span class="line">  函数格式：dict.popitem()</span><br><span class="line">  返回值：会在字典尾部，弹出键值对并删除，将删除的键值对按照元组类型返回</span><br><span class="line"></span><br><span class="line">(3)检索字典</span><br><span class="line">  第一、查询指定的value,通过指定的key找到对应的value</span><br><span class="line">  dic[1] &#x3D; &gt; &#39;one&#39;</span><br><span class="line">  第二、遍历字典</span><br><span class="line">  for key in dic:</span><br><span class="line">      dic[key]</span><br><span class="line"></span><br><span class="line">  &#x3D;&gt;&#39;one&#39;</span><br><span class="line">    &#39;two&#39;</span><br><span class="line">    &#39;three&#39;</span><br><span class="line">    &#39;four&#39;</span><br><span class="line">    &#39;five&#39;</span><br><span class="line"></span><br><span class="line">(4)字典与列表、元组的转换</span><br><span class="line">列表转成字典</span><br><span class="line">  list1 &#x3D; [[1,&#39;one&#39;],[2,&#39;two&#39;],[3,&#39;three&#39;]]</span><br><span class="line">  或</span><br><span class="line">  list1 &#x3D; [(1,&#39;one&#39;),(2,&#39;two&#39;),(3,&#39;three&#39;)]</span><br><span class="line">  dic &#x3D; dict(list1)</span><br><span class="line">  &#x3D;&gt;&#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;</span><br><span class="line">元组转成字典</span><br><span class="line">  tup &#x3D; ((1,&#39;one&#39;),(2,&#39;two&#39;),(3,&#39;three&#39;))</span><br><span class="line">  dic &#x3D; dict(tup)</span><br><span class="line">  &#x3D;&gt;&#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;</span><br><span class="line">注意：不管是元组还是列表，其作为key的那个值必须是不可变数据类型。</span><br><span class="line">同时，我们对字典进行新增和修改时，其key可以使用True或False，但是要注意在使用他们时字典会首先对已有的key进行比对，如果有重复的则进行修改（True&#x3D;&#x3D;1，False&#x3D;&#x3D;0）</span><br><span class="line">	</span><br><span class="line">(5)常用函数</span><br><span class="line">1)keys(),获得字典所有的key值集合</span><br><span class="line">函数格式：dict.keys()</span><br><span class="line">返回值：dict_keys 类型，实际内容为一个list列表。</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;1:&#39;one&#39;,2:&#39;two&#39;,3:&#39;three&#39;&#125;</span><br><span class="line">for key in dic.keys():</span><br><span class="line">     print(key,dic[key]) </span><br><span class="line">&#x3D;&gt;1 one</span><br><span class="line">  2 two</span><br><span class="line">  3 three</span><br><span class="line"></span><br><span class="line">2)values(),获得字典中所有的value值的集合</span><br><span class="line">函数格式：dict.values()</span><br><span class="line">返回值：dict_values类型，实际内容为一个list列表</span><br><span class="line"></span><br><span class="line">3)items(),获得字典中所有key&#x3D;value键值对的集合</span><br><span class="line">函数格式：dict.items()</span><br><span class="line">返回值：dict_items类型，实际内容为一个包含元组的list列表</span><br><span class="line">dic &#x3D; &#123;1:&#39;one&#39;,2:&#39;two&#39;,3:&#39;three&#39;&#125;</span><br><span class="line">dic.items()	   </span><br><span class="line">&#x3D;&gt;dict_items([(1, &#39;one&#39;), (2, &#39;two&#39;), (3, &#39;three&#39;)])</span><br><span class="line"></span><br><span class="line">4)get()，获得字典中指定key对应的value内容</span><br><span class="line">函数格式：dict.get(key)</span><br><span class="line">返回值：返回指定key对应的value，如果没有找到则不返回任何内容即返回None。例如：</span><br><span class="line">dic.get(5) &#x3D;&#x3D; None	   </span><br><span class="line">&#x3D;&gt;True</span><br><span class="line"></span><br><span class="line">5)setdefault()，返回指定key对应的内容，如果这个key不存在，那么就进行新增</span><br><span class="line">函数格式：dict.setdefault(key[,value]),其中key为键值，如果该key在字典中已经存在，那么不需要填写value参数；如果key值在字典中不存在，需要value参数。</span><br><span class="line">返回值：如果key值存在，返回该key对应的value内容；如果key不存在，则进行新增返回新增的value内容。</span><br><span class="line"></span><br><span class="line">6)update(),将新字典中的key&#x3D;value内容，添加到原有字典尾部，如果新字典内容中有key值与原字典的key值相同，那么就覆盖key值对应的原有value。</span><br><span class="line">函数格式：old_dict.update(new_dict)</span><br><span class="line">返回值：将新字典中的内容，添加到原有字典的尾部。</span><br><span class="line">dic &#x3D; &#123;1:&#39;麻辣米线&#39;,2:&#39;麻辣烫&#39;,3:&#39;凉皮&#39;,4:&#39;刀削面&#39;,5:&#39;兰州拉面&#39;&#125;</span><br><span class="line">dic2 &#x3D; &#123;&#39;one&#39;:&#39;美式咖啡&#39;,&#39;two&#39;:&#39;拿铁&#39;,&#39;three&#39;:&#39;卡布基诺&#39;,5:&#39;甜甜圈&#39;&#125;</span><br><span class="line">dic.update(dic2)</span><br><span class="line">&#x3D;&gt;&#123;1: &#39;麻辣米线&#39;, 2: &#39;麻辣烫&#39;, 3: &#39;凉皮&#39;, 4: &#39;刀削面&#39;, 5: &#39;甜甜圈&#39;, &#39;one&#39;: &#39;美式咖啡&#39;,      &#39;two&#39;: &#39;拿铁&#39;, &#39;three&#39;: &#39;卡布基诺&#39;&#125;</span><br><span class="line"></span><br><span class="line">7)fromkeys(),通过指定的key集合，生成一个新字典，其value值缺省为None</span><br><span class="line">函数格式：dict.fromkeys(iter1[,value]) 其中iter1为可迭代化集合，比如：列表、元组；value可以是任意数据类型。</span><br><span class="line">返回值：返回一个新字典，其中key为我们在参数中使用的iter1集合，值都为None或者指定的value。比如：</span><br><span class="line">dic3 &#x3D; dict(&#123;&#39;a&#39;:&#39;one&#39;,&#39;b&#39;:&#39;two&#39;,&#39;c&#39;:&#39;three&#39;&#125;)</span><br><span class="line">a &#x3D; dic3.fromkeys([1,2,3])</span><br><span class="line">&#x3D;&gt;&#123;1: None, 2: None, 3: None&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dic3 &#x3D; dict(&#123;&#39;a&#39;:&#39;one&#39;,&#39;b&#39;:&#39;two&#39;,&#39;c&#39;:&#39;three&#39;&#125;)</span><br><span class="line">a &#x3D; dic3.fromkeys([1,2,3],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])</span><br><span class="line">&#x3D;&gt;&#123;1: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 2: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 3: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125;</span><br><span class="line"></span><br><span class="line">讨论：</span><br><span class="line">列表的可迭代化</span><br><span class="line">当生成一个空列表时，因为列表中没有值，所以python并没有相应的内存地址分配给这个列表变量，当该列表添加元素后，python会自动给该列表扩充内存地址，那么地址都是依次连续的在内存中进行排列。</span><br></pre></td></tr></table></figure>

<h4 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、集合的概念：集合<span class="built_in">set</span>是一个无序的数据集合，可以存储各种数据类型的元素，同            时可以对集合中的元素进行新增、删除等操作，因此集合的长度是可变             的。并且集合是不允许有重复元素，如果出现重复元素，除去第一个元素           之外，都会被集合所忽略</span><br><span class="line">注意：<span class="built_in">set</span>是无序的，即存储元素到<span class="built_in">set</span>的顺序与这些元素输出的顺序无关。<span class="built_in">set</span>仍然是采用哈希算法，对这些元素进行存储的。</span><br><span class="line"></span><br><span class="line">2、集合的声明与赋值</span><br><span class="line">1）set1 = &#123;1,2,3&#125;   生成一个集合</span><br><span class="line">2）set1 = <span class="built_in">set</span>(&#123;1,2,3&#125;)</span><br><span class="line">3)set1 = <span class="built_in">set</span>()  生成一个空集合，请注意集合只能通过<span class="built_in">set</span>()函数来生成空集合，   而不是通过set1 = &#123;&#125;,这个表达式会生成一个空字典。</span><br><span class="line"></span><br><span class="line">3、数据类型转换</span><br><span class="line">字符串转成集合</span><br><span class="line">string = <span class="string">'hello'</span></span><br><span class="line">set1 = <span class="built_in">set</span>(string)</span><br><span class="line">=&gt;&#123;<span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'h'</span>, <span class="string">'e'</span>&#125;</span><br><span class="line"></span><br><span class="line">列表转成集合</span><br><span class="line">list1 = [1,2,3]</span><br><span class="line">set1 = <span class="built_in">set</span>(list1)</span><br><span class="line">=&gt;&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">元组转成集合</span><br><span class="line">tup = (1,2,3)</span><br><span class="line">set1 = <span class="built_in">set</span>(tup)</span><br><span class="line">&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">4、集合的操作</span><br><span class="line">1）元素的增加 add()</span><br><span class="line">函数格式：set.add(元素)</span><br><span class="line">返回值：无返回值</span><br><span class="line">结果：集合元素增加一个</span><br><span class="line">例如：</span><br><span class="line">set1=&gt;&#123;1, 2, 3&#125;</span><br><span class="line">set1.add(4)</span><br><span class="line"></span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">2）元素的删除</span><br><span class="line">第一、remove()</span><br><span class="line">函数格式：set.remove(元素)</span><br><span class="line">返回值：无返回值</span><br><span class="line">结果：集合指定的元素被删除</span><br><span class="line"><span class="built_in">set</span>  =&gt; &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">set1.remove(5)</span><br><span class="line">=&gt;&#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">第二、discard()</span><br><span class="line">函数格式：set.discard(元素)</span><br><span class="line">返回值：无返回值</span><br><span class="line">结果：集合中指定的元素被删除</span><br><span class="line"><span class="built_in">set</span>  =&gt; &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">set1.discard(5)</span><br><span class="line">=&gt;&#123;1, 2, 3, 4&#125;</span><br><span class="line">注意：上面两个方法，如果删除一个不存在的元素，其中remove()会报错，而discar()无反应</span><br><span class="line"></span><br><span class="line">第三、clear() 清空集合中所有的元素</span><br><span class="line">函数格式：set.clear()</span><br><span class="line">返回值：无返回值</span><br><span class="line">结果：清空集合中所有的元素</span><br><span class="line">set.clear()</span><br><span class="line"></span><br><span class="line">第四、del命令 删除集合，并释放其所占内存资源</span><br><span class="line">del <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">5、集合运算</span><br><span class="line">1）并集运算 (|)或union()</span><br><span class="line">两个集合进行并集运算，即将两个集合中的元素都合并到一个新的集合中，重复的元素只出现一次。</span><br><span class="line">例如：</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set1 | set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'tw'</span>, <span class="string">'fr'</span>, <span class="string">'zh'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">或者</span><br><span class="line">set1.union(set2)</span><br><span class="line"></span><br><span class="line">2）交集运算 （&amp;）或intersection()</span><br><span class="line">两个集合进行交集运算，即将两个集合中相同的元素合并到一个新的集合中。</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set1 &amp; set2 =&gt; &#123;<span class="string">'en'</span>&#125;</span><br><span class="line">或者</span><br><span class="line">set1.intersection(set2)</span><br><span class="line"></span><br><span class="line">3)差集运算（-）或difference()</span><br><span class="line">两个集合进行差集运算，即运算符左边的集合，与运算右边的集合进行差运算，相当于使用左边集合去除与右边集合相同的元素。</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set1 - set2 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>&#125;</span><br><span class="line">或者</span><br><span class="line">set1.difference(set2)</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 - set1 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>&#125;</span><br><span class="line">或者</span><br><span class="line">set2.difference(set1)</span><br><span class="line"></span><br><span class="line">4)对称差运算（^）或者symmetric_difference()</span><br><span class="line">两个集合进行对称差运算，即两个集合中除去相同元素，其他所有元素重新归并到一个新集合中。</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 ^ set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>,<span class="string">'jp'</span>, <span class="string">'fr'</span>&#125;</span><br><span class="line">set1.symmetric_difference(set2)</span><br><span class="line"></span><br><span class="line">5)子集与超集（父集）</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">subset =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>&#125;</span><br><span class="line">我们通过观察可以看到，subset中的内容，属于set1的一部分。因此，</span><br><span class="line">subset.issubset(set1) =&gt; True</span><br><span class="line">表示，subset是set1集合的一个子集合</span><br><span class="line">同理，我们也可以说，set1是subset的父集合</span><br><span class="line">set1.issuperset(subset) =&gt; True</span><br><span class="line"></span><br><span class="line">6、集合常用函数</span><br><span class="line">1）update()</span><br><span class="line">函数格式：set1.update(set2)</span><br><span class="line">返回值：无</span><br><span class="line">结果：我们将set2中的元素，添加到set1中，如果有相同的元素只保留一个。同时，该操作会修改set1的元素数量。</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set1.update(set2)</span><br><span class="line">set1 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'tw'</span>, <span class="string">'fr'</span>, <span class="string">'zh'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line"></span><br><span class="line">2)intersection_update()</span><br><span class="line">函数格式：set1.intersection_update(set2)</span><br><span class="line">返回值：无</span><br><span class="line">结果：我们使用set2中的元素，添加到set1中，其中，保留两个集合中相同的元素。其中，set1、set2中其他的元素被舍弃。</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set1.intersection_update(set2)</span><br><span class="line">set1 =&gt; &#123;<span class="string">'en'</span>&#125;</span><br><span class="line"></span><br><span class="line">3）symmetric_difference_update()</span><br><span class="line">函数格式：symmetric_difference_update()</span><br><span class="line">返回值：无</span><br><span class="line">结果：我们使用set1与set2进行运算，只保留两者除去相同元素之外的元素。</span><br><span class="line">set1 =&gt; &#123;<span class="string">'zh'</span>, <span class="string">'tw'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set2 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'en'</span>&#125;</span><br><span class="line">set1.symmetric_difference_update(set2)</span><br><span class="line">set1 =&gt; &#123;<span class="string">'jp'</span>, <span class="string">'fr'</span>, <span class="string">'zh'</span>, <span class="string">'tw'</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">range()函数自身并不会自动产生整数序列，它需要使用其他方式来调用它才会产生。</span><br></pre></td></tr></table></figure>

<h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：[表达式或函数  <span class="keyword">for</span> x <span class="keyword">in</span> 序列]</span><br><span class="line">含义：通过生成式中的循环，逐一产生x值，表达式使用X值进行相关运算。最终结果       作为列表的元素。也就意味着，循环多少次，就会产生多少个相关元素。</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">概念：迭代器访问元素，是从第一个元素开始，依次访问后续元素直到结束。其中迭代器只能向前不能回退。其包含两个方法iter()和next()。</span><br><span class="line">iter()用来创建一个迭代器，next()用来访问下一个元素。</span><br><span class="line">目前我们所学的字符串、列表、元组都可以创建迭代器，那么他们也是可迭代化的对象。</span><br><span class="line">迭代器两个步骤：</span><br><span class="line">1、当调用next()函数，会将迭代器当前位置状态进行改变</span><br><span class="line">2、会将下一个元素进行返回</span><br><span class="line"></span><br><span class="line">迭代器的延迟作用：迭代器生成的元素并不是在迭代器声明时，就准备好了的。通常时在调用迭代器需要提供该元素时生成的，也就是说只有在我们需要的时候迭代器才产生相关元素，不需要时并不会主动的生成相关元素。我们可以把迭代器看成一个容器，到我们需要时使用next()方法返回容器中的下一个值。</span><br><span class="line">迭代器实现了工厂模式的对象，它在你每次访问下一个值的时候给你返回。</span><br><span class="line"></span><br><span class="line">可迭代化（iterable）：表明相关的对象可以创建迭代器对象，同时他们自身都是可以进行<span class="keyword">for</span>数据遍历的。我们可以使用isinstance()来判断对象是否为可迭代化</span><br><span class="line"></span><br><span class="line">from collections import Iterable</span><br><span class="line">string = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">print</span>(isinstance(string, Iterable))  =&gt; True</span><br><span class="line">函数格式：isinstance(对象，类型)</span><br><span class="line">返回值：布尔值</span><br><span class="line">结果：如果指定的对象属于指定的类型，那么返回True，反之返回False</span><br><span class="line"></span><br><span class="line">enumerate()函数</span><br><span class="line">函数格式：enumerate(iterable)</span><br><span class="line">返回值：生成一个枚举对象</span><br><span class="line">例如：</span><br><span class="line">enum = enumberate([<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enum:</span><br><span class="line">    <span class="built_in">print</span>(i)    </span><br><span class="line">=&gt; (0, <span class="string">'one'</span>)</span><br><span class="line">   (1, <span class="string">'two'</span>)</span><br><span class="line">   (2, <span class="string">'three'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,value <span class="keyword">in</span> enum:</span><br><span class="line">    <span class="built_in">print</span>(i, value)  </span><br><span class="line">=&gt;0 one</span><br><span class="line">  1 two</span><br><span class="line">  2 three</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、创建方式</span><br><span class="line">第一种，使用列表推导式，将[]改为()，生成一个generator对象</span><br><span class="line">第二种，使用函数方式，采用yield关键字来实现</span><br><span class="line">2、使用</span><br><span class="line">生成器我们通常可以认为一种特殊的迭代器，但是它不需要像迭代器一样去实现__iter__,__next__方法。只需要使用yield关键字，该关键字可以在每次调用生成器函数时起到暂停作用，并将其值进行返回。同时还会记录当前运行值的状态。</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">迭代器和生成器</span><br><span class="line">1、容器是一系列的元素集合，str、list、<span class="built_in">set</span>、dict对象都可以看作是容器，容器都可以进行迭代（即用在<span class="keyword">while</span>或<span class="keyword">for</span>循环），凡是这样的容器我们都称为可迭代化对象（Iterable）。</span><br><span class="line">2、可迭代化对象都实现了__iter__方法，该方法返回一个迭代器对象。</span><br><span class="line">3、迭代器都拥有一个状态字段，用于记录下次迭代返回值。它实现了__next__和__iter__方法，迭代器不会一次性把所有的元素都加载到内存中，而是在需要的时候才生成返回结果。</span><br><span class="line">4、生成器是一种特殊的迭代器，它的返回值不是通过<span class="built_in">return</span>来返回的，而是通过yield来返回的。</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、函数的定义</span><br><span class="line">  函数的格式：def 函数名([参数列表])</span><br><span class="line">                执行代码</span><br><span class="line">  其中，函数名的命名方法方式与变量的要求相同，即只能是数字、字母、下划线三者构成，同时不能有数字开头。另外，函数的参数根据情况，可以有参，也可以无参。同时，参数的个数，可以1到N个。最后调用函数时，一定要保证该函数已经被定义。调用的函数名一致。</span><br><span class="line">2、函数的调用</span><br><span class="line">  函数在外部调用时，直接写函数名以及函数参数即可，不需要将函数体写出来。同时，函数是否有返回值，由其函数体最后一句代码是否为<span class="built_in">return</span>来决定的。如果有<span class="built_in">return</span>语句，那么就意味着该函数有返回值，如果没有返回值就意味着返回值为None</span><br><span class="line">  注意：函数使用<span class="built_in">return</span>作为返回值语句，该命令通常放在函数的最后一句，保证函数相关</span><br></pre></td></tr></table></figure>

<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、匿名函数</span><br><span class="line">    使用lambda关键字进行修饰，没有显示声明函数的名字。</span><br><span class="line">    函数格式：lambda 参数：表达式（返回值）</span><br><span class="line">    注意，在使用匿名函数时，因为其自身的情况限制，匿名函数并不能执行比较复杂的业务逻辑，即函数内的代码不能过多</span><br><span class="line"></span><br><span class="line">2、map函数()（映射函数）</span><br><span class="line">    函数格式；map(func,iterable)</span><br><span class="line">    返回值；map对象（迭代器）</span><br><span class="line">    说明：map函数主要作用是，将指定函数与序列中的元素进行映射，并完成函数中功能的批量操作，返回值为一个迭代器。我们可以使用<span class="keyword">for</span>循环或next()函数进行遍历。通常情况下，如果映射的函数较为简单，我们就不单独声明函数，而是采用匿名函数来实现，这样也能提高运行效率。</span><br><span class="line"></span><br><span class="line">3、reduce()函数（归纳函数）</span><br><span class="line">    函数格式：reduce(func,iterator)</span><br><span class="line">    返回值：返回函数计算结果，具体类型根据函数的返回值来定</span><br><span class="line">    说明：reduce()函数中的func，一定要设为两个参数，用来接收迭代器返回值，操作顺序为首先接收第一、第二个值，进行运算；运算结果再与第三个值进行运行，以此类推，知道迭代器迭代完全部数据。</span><br><span class="line"></span><br><span class="line">4、filter()函数（过滤函数）</span><br><span class="line">    函数格式：filter(func,iterable)</span><br><span class="line">    返回值：返回一个迭代器</span><br><span class="line">    说明：过滤函数与映射函数类似，都需要将函数作用于序列中的每个元素，根据函数判断True或False，返回相关元素。</span><br><span class="line"></span><br><span class="line">5、递归函数</span><br><span class="line">    递归概念：就是使用自身函数对自身进行调用，每调用一次将当前的运行结果保存在函数的堆栈中，以副本形式保存，一直到最后完成全部调用。然后逐一向外将当期函数的结果返回并退出到其调用的位置。</span><br><span class="line">    在Python中，通常推挤使用迭代，递归本身对内存的消耗和运行效率低下的问题较少使用。</span><br></pre></td></tr></table></figure>

<h3 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h3><h4 id="文本文件的输入输出（txt）"><a href="#文本文件的输入输出（txt）" class="headerlink" title="文本文件的输入输出（txt）"></a>文本文件的输入输出（txt）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、格式化函数</span><br><span class="line">    repr()</span><br><span class="line">    函数格式：repr(Object)</span><br><span class="line">    返回值：返回一个字符串类型的数据</span><br><span class="line">    说明：该函数，将参数中的对象进行处理，变为字符串类型，其中如果参数为字符串仍然会在外部加上“”，其内部的字符串的边界符仍然存在。例如：</span><br><span class="line">    repr(<span class="string">'hello world'</span>)</span><br><span class="line">    <span class="string">"'hello world'"</span></span><br><span class="line">    </span><br><span class="line">    居左、居右、居中函数</span><br><span class="line">    rjust()/ljust()/center()</span><br><span class="line">    函数格式：rjust(int) /ljust(int)/center()</span><br><span class="line">    返回值：无</span><br><span class="line">    说明：该函数，将输出的字符串居右(居左/居中)对其，左侧(右侧/两侧)使用参数中规定的空格数来对齐</span><br><span class="line"></span><br><span class="line">2、文本文件的输入输出</span><br><span class="line">    文本文件的操作步骤：</span><br><span class="line">    1、打开文件</span><br><span class="line">        函数格式：open(file,mode,buffering,encoding)</span><br><span class="line">        返回值：返回一个文件对象，用来对文件进行操作。</span><br><span class="line">        说明：该函数主要是进行文件打开操作，如果文件不存在就新建一个文件。如果存在就打开原有文件。</span><br><span class="line">    </span><br><span class="line">    2、操作文件</span><br><span class="line">        1）写文件</span><br><span class="line">        函数格式：write(str)</span><br><span class="line">        返回值：返回所写入文件的字符串中的字符数。</span><br><span class="line">        说明：该函数可以一次性写入一个字符串内容，到文件中。每次写入文件是，如果使用的模式为w，那么因为着本次写入为覆盖式写入，即写入内容会替换掉原有文件内容。</span><br><span class="line">        函数格式：writelines(sequence)</span><br><span class="line">        返回值：无</span><br><span class="line">        说明：该函数可以使用列表、字符串、元组、集合、字典等作为参数，其中这些序列中的元素必须为字符串类型，同时也可以一次性写入多行字符串。</span><br><span class="line"></span><br><span class="line">        补充：</span><br><span class="line">        f.flush():强制将缓存区内内容写入外部介质中，但是不关闭文件。</span><br><span class="line"></span><br><span class="line">        2）读文件</span><br><span class="line">        函数格式：<span class="built_in">read</span>([size])</span><br><span class="line">        返回值：返回按字节逐一读取的数据。</span><br><span class="line">        说明：该函数按照字节个数，逐一读取文件中的数据。如果没有规定读取数据的字节大小即size，一直读完文件中全部数据，如果规定了数据的字节大小，只读取规定字节数的内容。</span><br><span class="line"></span><br><span class="line">        函数格式：readline()</span><br><span class="line">        返回值：返回读取的一行字符串</span><br><span class="line">        说明：该函数一次能够读取文件中一行内容，如果需要读取全部内容，需要配合<span class="keyword">while</span>循环使用，注意使用读取到的文件内容作为条件判断，即文件内容为空字符串时，退出循环。</span><br><span class="line"></span><br><span class="line">        函数格式：readlines()</span><br><span class="line">        返回值：返回一个包含多个字符串的列表。</span><br><span class="line">        说明：该函数能够一次性将文件中的数据全部读取出来，然后将文件中每行字符串，作为一个列表的元素，将其组装成一个列表返回。</span><br><span class="line"></span><br><span class="line">    3、关闭文件</span><br><span class="line">        函数格式：close()</span><br><span class="line">        返回值：无</span><br><span class="line">        说明：当我们操作文件时，进行相关的写入操作，Python将数据写入文件之前，会将文件保存在文件缓冲区中，在我们调用close()函数时，首先会将文件缓冲区内还没有写入到文件中的数据进行刷新并强制写入文件，然后关闭Python与文件的通道，释放相关资源。</span><br><span class="line"></span><br><span class="line">3、json格式处理</span><br><span class="line">    在Python中，提供了json模块可以实现对特殊数据结构的读写。比如：列表和字典。</span><br><span class="line">    1）将嵌套列表或字典转为json格式数据</span><br><span class="line">    import json</span><br><span class="line">    item = json.dumps(list/dict)</span><br><span class="line">    file.writelines(item)</span><br><span class="line"></span><br><span class="line">    json.dump(list, file)</span><br><span class="line">    2)将文件中的列表或字典json字符串读取出来</span><br><span class="line">    f= open(file,mode)</span><br><span class="line">    json.load(f)</span><br><span class="line"></span><br><span class="line">4、文件及路径操作函数</span><br><span class="line">    1）isfile()与isdir() （os.path模块）</span><br><span class="line">    函数格式：os.path.isfile(file)</span><br><span class="line">    返回值：bool</span><br><span class="line">    说明：根据传入的参数，判断该内容是否为文件类型。如果是文件类型返回True，如果不是返回False</span><br><span class="line">    </span><br><span class="line">    isdir()</span><br><span class="line">    函数格式：os.path.isdir(path)</span><br><span class="line">    返回值：bool</span><br><span class="line">    说明：根据传入的参数，判断内容是否为目录类型，如果是目录就返回True，如果不是返回False</span><br><span class="line">    </span><br><span class="line">    2）创建路径 mkdir()、删除路径removedirs() (os模块)</span><br><span class="line">    函数格式：os.mkdir(path)</span><br><span class="line">    返回值：无</span><br><span class="line">    说明：如果指定路径中不存在该目录，那么创建该目录。注意，如果存在同名目录，则报错</span><br><span class="line"></span><br><span class="line">    函数格式：os.removedirs(path)，os.rmdir(path)</span><br><span class="line">    返回值：无</span><br><span class="line">    说明：删除指定的目录，如果该目录中存在文件或子目录，都不允许删除。否则报错。</span><br><span class="line">    </span><br><span class="line">    3）删除文件 remove() （os模块）</span><br><span class="line">    函数格式：os.remove(file)</span><br><span class="line">    返回值：无</span><br><span class="line">    说明：删除指定的文件，如果该文件不存在则报错。如果文件存在就删除。</span><br><span class="line">    </span><br><span class="line">    4）判断文件/目录是否存在 exists()</span><br><span class="line">    函数格式：os.path.exists(file/path)</span><br><span class="line">    返回值：bool</span><br><span class="line">    说明：判断指定的文件或路径是否存在，如果存在返回True，如果不存在返回False。</span><br><span class="line">    </span><br><span class="line">    5)返回指定路径下，所有子路径 listdir()</span><br><span class="line">    函数格式：os.listdir(path)</span><br><span class="line">    返回值：list</span><br><span class="line">    说明：返回指定路径下，所有的子路径。</span><br><span class="line">    </span><br><span class="line">    6）返回当前路径 getcwd()</span><br><span class="line">    函数格式：os.getcwd()</span><br><span class="line">    返回值：path</span><br><span class="line">    说明：返回当前程序所在的绝对路径</span><br><span class="line">    </span><br><span class="line">    7）返回文件大小 getsize()</span><br><span class="line">    函数格式：path.getsize()</span><br><span class="line">    返回值：int</span><br><span class="line">    说明：返回指定文件的大小，单位是字节</span><br><span class="line">    </span><br><span class="line">    8）重命名 rename()</span><br><span class="line">    函数格式：os.rename(oldfilename/oldpath,newfilename/newpath)</span><br><span class="line">    返回值：无</span><br><span class="line">    说明:将指定的文件名或目录名进行重命名。</span><br><span class="line">    </span><br><span class="line">    9）替换 replace()</span><br><span class="line">    函数格式：os.replace(src,dst)</span><br><span class="line">    返回值：无</span><br><span class="line">    说明：使用目标文件替换掉原文件</span><br><span class="line"></span><br><span class="line">    注意：在Python3.x版本中，将pathlib作为内置模块进行了引入。我们可以通过使用from pathlib import Path，使用。</span><br><span class="line">    其使用的前提为：需要先创建一个path对象，然后对其进行操作。</span><br><span class="line">    p = Path(<span class="string">'c:\pythoncode\etc'</span>)</span><br><span class="line">    具体方法，大家自行学习。</span><br></pre></td></tr></table></figure>

<h4 id="二进制文件的输入输出"><a href="#二进制文件的输入输出" class="headerlink" title="二进制文件的输入输出"></a>二进制文件的输入输出</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、struct和pickle</span><br><span class="line">    使用struct模块，进行数据的输入输出</span><br><span class="line">        使用步骤：</span><br><span class="line">            第一、对要写入文件中的各种类型数据，进行统一打包</span><br><span class="line">            struct.pack(<span class="string">'if?'</span>,10,12.4,True) 其中，i：代表整型，f:代表浮点型 ？：代表布尔型</span><br><span class="line">            第二、使用write()写入，写入后以二进制的方式进行文件存储</span><br><span class="line">            第三、读取时，首先采用struct.unpack()来解包里面包含的相关数据，返回一个序列，即写入时的顺序，与读取时的顺序应该一致。</span><br><span class="line">        注意：需要将所有写入的数据，一次性都封装到一个bytes中，因为在Python中没有bytes的概念，所以需要第三方的模块进行封装</span><br><span class="line"></span><br><span class="line">    使用pickle模块，进行数据的输入输出</span><br><span class="line">        使用步骤：</span><br><span class="line">            第一、对要写入文件中的数据，进行统一的写入。例如：</span><br><span class="line">            f = open(<span class="string">'myfile.dat'</span>,<span class="string">'wb'</span>)</span><br><span class="line">            pickle.dump(10,f)</span><br><span class="line">            第二、读取数据时，同理要逐一读取。例如：</span><br><span class="line">            pickle.load(f)</span><br><span class="line">        注意：在使用时，我们能够观察到该模块的dump和load函数，与前面所学的json函数一致，在Python中json和pickle都能够实现序列化和反序列化的两个模块</span><br><span class="line"></span><br><span class="line">2、文件的定位</span><br><span class="line">    函数格式：seek(n)</span><br><span class="line">    返回值；返回指定的位置</span><br><span class="line">    说明：痛过指定的元素位置，将文件的指针移动到该位置</span><br><span class="line">    seek()函数有三个固定值，分别为：0，1，2</span><br><span class="line">    0：文件的开头</span><br><span class="line">    1：文件的当前位置</span><br><span class="line">    2：文件的结尾位置</span><br><span class="line">    seek(0,2):代表着将指针定位到文件尾，然后进行添加操作</span><br><span class="line">    seek(0,1):代表着在当前指针位置，进行替换</span><br></pre></td></tr></table></figure>

<h4 id="Excel文件的输入输出"><a href="#Excel文件的输入输出" class="headerlink" title="Excel文件的输入输出"></a>Excel文件的输入输出</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、需要三个主要模式：</span><br><span class="line">    xlrd：用来读取Excel文件的内容</span><br><span class="line">    xlwt：用来生成Excel文件</span><br><span class="line">    xlutils：用来实现Excel文件的复制</span><br><span class="line">2、步骤：</span><br><span class="line">    首先：xlrd</span><br><span class="line">    open_workbok()</span><br><span class="line">    函数格式：open_workbook(文件名)</span><br><span class="line">    返回值：返回Excel对象</span><br><span class="line">    说明：打开指定的Excel文件，生成一个Excel对象用来实现读取行、列及单元格内容。</span><br><span class="line">    </span><br><span class="line">    函数格式：sheet_by_name(sheet页面名)/sheet_by_index(sheet页索引位，默认从0开始)</span><br><span class="line">    返回值：sheet页对象</span><br><span class="line">    说明：找到指定的sheet页，生成一个对应的sheet页对象，对其内部的数据进行检索</span><br><span class="line"></span><br><span class="line">    函数格式：sheet.cell(rownum,colnum)</span><br><span class="line">    返回值：返回指定行列的单元格对象，如果要获取其中的内容，调用value属性</span><br><span class="line">    说明：通过指定行列，能够确定一个单元格</span><br><span class="line"></span><br><span class="line">    其次：xlwt</span><br><span class="line">    函数格式：Workbook()</span><br><span class="line">    返回值：返回一个新创建的Excel空对象</span><br><span class="line">    说明：该函数用来生成一个Excel对象，但是该对象没有任何内容</span><br><span class="line"></span><br><span class="line">    函数格式；add_sheet(sheet名字)</span><br><span class="line">    返回值：返回一个新创建的sheet页对象</span><br><span class="line">    说明：该函数用来新增一个空的sheet页对象</span><br><span class="line"></span><br><span class="line">    函数格式：write(row,col,value)</span><br><span class="line">    返回值：无</span><br><span class="line">    说明：对指定的行列单元格内，写入value内容</span><br><span class="line"></span><br><span class="line">    最后：xlutils</span><br><span class="line">    函数格式；copy(Excel对象)</span><br><span class="line">    返回值：返回一个指定对象副本</span><br><span class="line">    说明：在Python中对Excel的修改，都是生成一个对应的副本，修改后保存</span><br><span class="line"></span><br><span class="line">    函数格式：get_sheet(索引位)</span><br><span class="line">    返回值：返回一个指定对象副本中的sheet页</span><br><span class="line">    说明：我们实际修改的数据，都是位于sheet页中。因此要获取到指定的sheet页</span><br></pre></td></tr></table></figure>

<h4 id="XML文件的输入输出"><a href="#XML文件的输入输出" class="headerlink" title="XML文件的输入输出"></a>XML文件的输入输出</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XMl文件的解析的两种方式：DOM与SAX</span><br><span class="line">    DOM：文档对象模型，是Python处理XML文件的标准模式。一个DOM的解析器在解析XML文件是，一次性读入整个文档，把文档中的所有元素（标签和文本）保存在内存中的一个树形结构，然后我们利用DOM提供的各种函数，来读取或修改文档的内容。</span><br><span class="line">    SAX：是一种时间驱动的API，利用SAX解析XML文件并向事件处理器发送事件，比如：元素开始、元素结束。常用在1）大型文档处理2）只需要文件的部分内容，或者从文件中得到特定的部分3）建立自己的对象模型。、</span><br><span class="line"></span><br><span class="line">DOM与SAX对比：</span><br><span class="line">    1、DOM解析需要读取整个文档到内存中，并且将所有元素保存在树形结构。那也就意味着，可以根据树形结构导航到任一节点，获取其相关内容。</span><br><span class="line">    2、SAX解析文档，将文档边读入边解析的方式，不需要一次性读入全部文档内容，只需要读入一部分即可。同时，因为其边读入边解析的工作方式，能够适应大文件的解析，提高解析效率。</span><br><span class="line"></span><br><span class="line">SAX解析文件步骤：</span><br><span class="line">    1、创建解析器</span><br><span class="line">    parser = sax.make_parser()</span><br><span class="line">    </span><br><span class="line">    2、读取xml文档</span><br><span class="line">    xml.sax.parse(xmlfile)</span><br><span class="line">    </span><br><span class="line">    3、设置ContentHandler对象，重写startDocument、endDocument、startElement、endElement方法</span><br><span class="line"></span><br><span class="line">    startDocument():文档载入时调用，文档开始</span><br><span class="line">    endDocument()：当解析器达到文档结尾时调用</span><br><span class="line">    </span><br><span class="line">    startElement(name,attrs):当遇到XML标签时调用，name是标签的名字，attrs标签的属性字典</span><br><span class="line">    endElement(name):当遇到XML标签结束时调用，name是标签名</span><br><span class="line">    </span><br><span class="line">    4、使用SAX解析文件，需要为解析器配置ContentHandler，定义了如何解析标签，以及处理标签间文本内容的业务逻辑。</span><br><span class="line">    carhandler = CarHandler()</span><br><span class="line">    parser.setContentHandler(carhandler)</span><br></pre></td></tr></table></figure>

<h3 id="包与模块"><a href="#包与模块" class="headerlink" title="包与模块"></a>包与模块</h3><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、基本概念：</span><br><span class="line">    在Python中进行Python定义与声明的文件，以.py结尾。使用import或from  import导入的文件，我们称为模块。</span><br><span class="line"></span><br><span class="line">2、模块的优势：</span><br><span class="line">    首先，使用模块，可以将常用的功能和变量，统一分类存储在不同的文件中，在使用时进行导入。提供了代码的可维护性。</span><br><span class="line">    其次，使用模块因为将常用功能进行了统一调用，提高了代码的复用性。</span><br><span class="line">    最后，解决了在同一文件中，方法和变量重名的问题。</span><br><span class="line"></span><br><span class="line">3、导入时的问题：</span><br><span class="line">    如果导入了与文件同名的函数（方法名相同，函数参数个数相同）时，需要使用模块名调用函数，与文件中的函数进行区分，例如：</span><br><span class="line">        import my</span><br><span class="line">        my.show()</span><br><span class="line">        def show():</span><br><span class="line">        pass</span><br><span class="line">        show()</span><br><span class="line"></span><br><span class="line">4、模块可以在Python文件中，实现多次import导入，但是只有第一次导入时才真正将模块中的内容运行、方法载入，其他在进行导入时，Python解析器会先检测是否已经载入该模块，如果载入就不再执行相关操作。</span><br><span class="line">总结：</span><br><span class="line">  模块载入一共分三个步骤：</span><br><span class="line">  (1)为模块的导入创建命名空间（划分新的内存地址），被载入的文件按照全局作用域来使用。</span><br><span class="line">  (2)模块载入后，将在上一步操作中创建的命名空间中，执行模块中的代码</span><br><span class="line">  (3)创建一个模块的名字，来引用模块所在的命名空间。my.show()</span><br></pre></td></tr></table></figure>

<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、概念：</span><br><span class="line">    包在Python中定义为可以包含多个模块文件的目录，其中必须包含一个名为“__init__.py”的文件，用来初始化包。</span><br><span class="line"></span><br><span class="line">2、包在调用的时候，首先会初始化__init__.py文件，主要功能为包中模块运行时提供所需要的相关数据，比如数据库用户名称、密码、地址等内容。</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、概念</span><br><span class="line">    指因程序出错在正常的执行流程之外，采取的行为。异常是一个事件，会在程序的执行过程中执行，并影响程序的执行</span><br><span class="line"></span><br><span class="line">2、异常的阶段</span><br><span class="line">    第一、产生异常（比如：代码错误、业务逻辑错误）</span><br><span class="line">    第二、处理异常（比如：将异常提示更加可理解、增强代码的健壮性）</span><br><span class="line">3、常见的异常类</span><br><span class="line">    Exception：Python中所有异常的父类。</span><br><span class="line">    NameError：访问一个未声明的变量。</span><br><span class="line">    keyError：访问一个不存在的字典key</span><br><span class="line">    IndexError：索引超出序列的范围。</span><br><span class="line">    ValueError：传给函数的参数类型不正确。</span><br><span class="line">    IOError：文件操作时输入输出错误</span><br><span class="line">4、异常处理流程</span><br><span class="line">    基本语法：</span><br><span class="line">        try：</span><br><span class="line">            可能会产生异常的代码</span><br><span class="line">        except 对应的异常 as 别名：</span><br><span class="line">            异常处理语句</span><br><span class="line">    说明：在try中，放置可能会产生错误的相关代码；except后标明对应的异常类型，一旦try中产生相关异常，except后声明的异常类能够对应捕获，执行相关异常处理语句。如果try外面后续还有其他语句，会继续执行。在产生异常时，出现异常的语句后，如果还有其他语句则不会执行。</span><br><span class="line"></span><br><span class="line">        try：</span><br><span class="line">            可能会产生异常的代码</span><br><span class="line">        except 对应异常 as 别名：</span><br><span class="line">            异常处理语句</span><br><span class="line">        <span class="keyword">else</span>：</span><br><span class="line">            程序代码</span><br><span class="line">    说明：在此结构中，如果try中的代码出现异常，则使用except后面声明的异常类进行捕获处理，如果没有异常出现，则执行<span class="keyword">else</span>内部的代码。</span><br><span class="line"></span><br><span class="line">        try：</span><br><span class="line">            可能出现异常的代码</span><br><span class="line">        except 对应异常 as 别名：</span><br><span class="line">            异常处理语句</span><br><span class="line">        except 对应异常 as 别名：</span><br><span class="line">            异常处理语句</span><br><span class="line">    说明；当try中有多行代码可能会出现不同的异常，那么使用多个except与之对应，根据产生的异常的顺序来依次捕获处理。</span><br><span class="line"></span><br><span class="line">        try：</span><br><span class="line">            可能产生异常的代码</span><br><span class="line">        except 对应异常 as 别名：</span><br><span class="line">            异常处理语句</span><br><span class="line">        finally：</span><br><span class="line">            代码</span><br><span class="line">    说明：在异常捕获处理流程中，使用finally来控制，表明不管是否出现异常进行捕获，最后代码都将允许finally内部的语句。</span><br><span class="line"></span><br><span class="line">    注意：finally中的语句，不管前面的代码出现何种操作，比如：<span class="built_in">break</span>、<span class="built_in">return</span>、<span class="built_in">exit</span>等都会执行完finally内部的代码后，才会实现。</span><br><span class="line"></span><br><span class="line">5、异常的分类</span><br><span class="line">    在Python中所有的异常都继承BaseExcept，如下：</span><br><span class="line">               |-----&gt; KeyboardInterrupt(键盘中断异常)</span><br><span class="line">               |</span><br><span class="line">    BaseExcept |-----&gt; SystemExit(系统退出异常)</span><br><span class="line">               |</span><br><span class="line">               |-----&gt; Except(其他所有异常的父类)</span><br><span class="line">    其中：KeyboardInterrupt在使用强制中断程序时产生。</span><br><span class="line">        SystemExit在使用sys.exit()函数时产生。</span><br><span class="line"></span><br><span class="line">6、主动抛出异常</span><br><span class="line">    raise 异常类对象实例或自定义异常类实例</span><br><span class="line">    raise IOError(<span class="string">'IO错误'</span>)</span><br><span class="line"></span><br><span class="line">7、finally的替换写法</span><br><span class="line">    with open(<span class="string">'myfile.txt'</span>,<span class="string">'r'</span>) as f:</span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">    其中打开、的文件对象f，在执行完内容的读取后，被强行关闭。即使在文件读取过程中，出现错误，也会被关闭。</span><br><span class="line">    </span><br><span class="line">8、使用异常机制的优势：</span><br><span class="line">    第一、把错误控制与业务逻辑进行区分，增强了程序的可读性和健壮性。</span><br><span class="line">    第二、代码结构更加清晰，复杂的业务流程的实现更加便利。</span><br><span class="line">    第三、程序是容错性更强，不会以为一个下bug导致整体崩溃。</span><br><span class="line"></span><br><span class="line">9、asset 断言</span><br><span class="line">    语法格式：assert 表达式，断言内容。代码如下</span><br><span class="line">        try:</span><br><span class="line">            assert 1==2,<span class="string">'1 不等于 2'</span></span><br><span class="line">        except AssertionError as ae:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'&#123;&#125;&#123;&#125;'</span>.format(ae.__class__.__name__, ae))</span><br><span class="line">    如果断言表达式为真，则正常执行，如果不为真，则返回断言内容，作为异常捕获的输出结果。</span><br></pre></td></tr></table></figure>

<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、面向对象的概念</span><br><span class="line">    类：指具有相同属性或行为的一组事物。</span><br><span class="line">    对象：是指类的具体化。</span><br><span class="line">    类与对象的关系</span><br><span class="line">    类是一组对象的抽象表示，而对象是类的具体化表现。</span><br><span class="line"></span><br><span class="line">2、类的语法结构</span><br><span class="line">    </span><br><span class="line">    1）如果类中声明了函数，其函数的参数，必须有一个默认的参数为self，self代表了该类的实例化对象。</span><br><span class="line">        class 类名：</span><br><span class="line">            变量声明语句</span><br><span class="line">            执行语句</span><br><span class="line">            def func(self):</span><br><span class="line">                执行语句</span><br><span class="line">        其中，类名首字母要求大写（约定俗成），遵守Python命名规则，不能以数字开头，通常我们都是字母开头。</span><br><span class="line">    </span><br><span class="line">    2）如果在类中声明了变量，且该变量位于函数体之外，这个变量我们成为类变量，类变量是公共的。类变量的调用可以直接使用类名进行调用，比如：</span><br><span class="line">        class Dog:  <span class="comment"># 定义一个类，类名Animal</span></span><br><span class="line">            color = <span class="string">'灰色'</span></span><br><span class="line">            leg_num = 4</span><br><span class="line">            weight = 20</span><br><span class="line">            width = 150</span><br><span class="line"></span><br><span class="line">            def wangwang(self):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'wangwangwangwang'</span>)</span><br><span class="line"></span><br><span class="line">            def eat(self):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'一顿饭20块钱'</span>)</span><br><span class="line"></span><br><span class="line">            def run(self):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'非常快'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        husky = Dog()  <span class="comment"># 将类实例化成对象，对象为dog</span></span><br><span class="line">        husky.run()</span><br><span class="line">        Dog.color</span><br><span class="line"></span><br><span class="line">        类变量，作为公共的变量，不管类实例化多少个对象，都只实例一份类变量。而且类变量会在对象实例化之前载入内容，一旦改变了类变量中的内容，所有对象中调用这个类变量的值都会随之改变。</span><br><span class="line"></span><br><span class="line">    3)在类实例化对象时，会将其定义的属性和行为，生成一份副本给具体的实例化对象。对象与对象之间，他们的属性和行为是不相互干扰的。</span><br><span class="line"></span><br><span class="line">        class Dog:  <span class="comment"># 定义一个类，类名Animal</span></span><br><span class="line">            color = <span class="string">'灰色'</span></span><br><span class="line"></span><br><span class="line">            def __init__(self, num):</span><br><span class="line">                self.num = num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            def getNum(self):</span><br><span class="line">                <span class="built_in">print</span>(self.num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        husky = Dog(5)  <span class="comment"># 将类实例化成对象，对象为dog</span></span><br><span class="line">        samoye = Dog(3)</span><br><span class="line">        husky.getNum()</span><br><span class="line">        samoye.getNum()</span><br><span class="line"></span><br><span class="line">        我们在实例化Dog类时，生成两个对象husky、samoye，这两对象在实例化的过程中会生成两套成员变量和函数，他们的相互不干扰的。我们可以观察上面的代码，发现num变量属于成员变量，即husky和samoye各有持有相同的成员变量，但是修改num的值，husky为5，而samoye为3。结果表明他们的成员变量只能归各自的对象所拥有，并进行改变。对象与对象之间不会相互影响。</span><br><span class="line">    4）使用构造函数，来初始化成员变量</span><br><span class="line">        class Person:</span><br><span class="line"></span><br><span class="line">            def __init__(self):  <span class="comment"># 构造函数，在实例化对象时被默认调用，用来给对象的成员变量赋值</span></span><br><span class="line">                self.name = <span class="string">'tom'</span></span><br><span class="line">                self.age = 21</span><br><span class="line">                self.tel = <span class="string">'1350000000'</span></span><br><span class="line">                self.address = <span class="string">'北京'</span></span><br><span class="line">                self.sex = <span class="string">'男'</span></span><br><span class="line">            </span><br><span class="line">            def setName(self, name):</span><br><span class="line">                self.name = name</span><br><span class="line">            </span><br><span class="line">            def getName(self):</span><br><span class="line">                <span class="built_in">return</span> self.name</span><br><span class="line">        p1 = Person()</span><br><span class="line">        p1.name</span><br><span class="line">        使用__init__()函数，用来初始化成员变量。对象在实例化时，会默认的调用__init__()函数，同时将成员变量进行初始化。同时，在构造函数中，使用self.变量名进行初始化的成员变量，都是公有的。即在类外可以通过实例化的对象调用。</span><br><span class="line"></span><br><span class="line">3、类变量与成员变量的区别</span><br><span class="line">    1）类变量是声明在类中，位于函数之外声明的变量。这些变量时公共的，即在类外使用类名.类变量     的方式进行调用。我们一旦修改类变量的值，所有调用类变量的内容均发生改变。</span><br><span class="line">    </span><br><span class="line">    2）成员变量，是声明在类中的构造函数中，通过self.变量来进行声明赋值的。这些成员变量是公有     的，即在类外可以通过对象名.成员变量的方式进行调用。所有的对象都有自己的成员变量，也就     意味着每个对象的成员变量都是独立的，不会相互干扰。</span><br><span class="line">    </span><br><span class="line">    3）类变量是该类所有实例化对象所公有的，它会早于对象实例化之前被载入内容中。</span><br><span class="line">       成员变量都是跟随对象实例化的过程中，被声明出来的。它是伴随着对象的产生而产生，消亡而消亡的。</span><br><span class="line">    </span><br><span class="line">    4）成员变量和方法，默认情况下都是公有的。也就是说在类外可以直接使用对象进     行调用。我们可以通过为成员变量设置双下划线，将其标识为私有的成员变量，     例如：self.__name = <span class="string">'tom'</span>。私有的成员变量只能在类内进行直接使用，类外    必须通过相关方法进行间接调用。</span><br><span class="line"></span><br><span class="line">4、Python中对象创建的流程</span><br><span class="line">    1、Python创建一个对象，首先要调用__new__方法，用来创建并返回一个对象。通常，Python中不需要我们直接显示调用，它会默认调用object.__new__()方法</span><br><span class="line">    2、然后，调用__init__方法，对该对象进行初始化。</span><br><span class="line"></span><br><span class="line">5、析构函数：</span><br><span class="line">    1、析构函数与构造函数一样，都是Python中特殊的函数。</span><br><span class="line">    2、析构函数如果用户没有定义的话，Python会提供一个默认的析构函数</span><br><span class="line">    3、析构函数__del__(self)，作用用来释放掉对象所占用的内存空间，在Python回收对象空间之前自动被执行。</span><br><span class="line">    4、通常在析构函数中，主要是将对象中占用大量资源的变量进行手动的释放，便于后续Python解释器去回收这些内存空间。</span><br></pre></td></tr></table></figure>
<p>###继承</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）Python中能够实现单继承与多继承。</span><br><span class="line">    单继承：就是子类只有一个直接父类。</span><br><span class="line">    多继承：子类有两个及两个以上的直接父类。</span><br><span class="line"></span><br><span class="line">2）子类继承父类，子类可以继承父类的相关特征。子类继承了父类的方法，如果在多继承情况下，父类     出现同名函数，那么子类继承该函数时，根据继承的顺序进行调用。</span><br><span class="line"></span><br><span class="line">3）super()函数，它指代了当前类的父类。我们可以在子类中调用super函数，用来初始化父类。但是使     用super()调用父类的构造函数时，只能对多继承中的第一个父类生效。</span><br><span class="line"></span><br><span class="line">4)抽象与继承的区别与关系</span><br><span class="line">    抽象：指对同一类别事物的相似部分进行抽取。抽象我们认为是对具体化对象的相关行为和属性的泛化过程。</span><br><span class="line">    继承：Python中我们通常认为类就是一个抽象的内容。类本身并不能直接执行，需要通过继承，进行对象的实例化，进而获得具体的对象本身，才能执行相关的功能。</span><br><span class="line">    也就是说继承其实是抽象的具体化过程。</span><br><span class="line"></span><br><span class="line">5）多继承中，当一个子类继承多个父类时，我们需要如下声明：</span><br><span class="line">    class SubClass(A,B):</span><br><span class="line">    其中，A、B是SubClass的父类。那么，如果我们分为两种个情况：</span><br><span class="line">    第一，子类中没有显式的定义__init__()，那么在实例化子类时调用其父类的构造函数。如果有多个类，都定义了__init()函数，那么它会调用第一个具有__init__()函数的父类。</span><br><span class="line">    第二，子类中显式的定义理论__init_(),那么实例化子类时不再调用父类的构造函数。此时，如果我们要调用父类的构造函数，有两种方法。</span><br><span class="line">    1）在子类的构造函数中，显式的调用对应父类的构造函数，例如：</span><br><span class="line">    A.__init__()</span><br><span class="line">    2)采用super()函数，super().__init__()或者super(子类，self).__init__()</span><br><span class="line">    但是如果遇到其多个父类，他们的构造函数同名时，我们根据他们在MRO中的顺序，分别调用他们，例如：</span><br><span class="line">    class SubClass(B, A):</span><br><span class="line">        def __init__(self):</span><br><span class="line">            super().__init__()   <span class="comment"># 此处调用了父类B</span></span><br><span class="line">            super(B, self).__init__() <span class="comment">#此处调用了父类C</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'我是子类'</span>)</span><br><span class="line">    注意，在这里不要看到super就认为是父类，但是在多继承时，实际上super指的是MRO中的下一个类。</span><br><span class="line"></span><br><span class="line">6）封装</span><br><span class="line">    在Python中，我们针对其内部细节进行封装。通常我们将属性定义为私有类型，意味着在类外无法直接访问。可以通过相关的方法对其进行调用。</span><br><span class="line">    私有的成员变量和方法，都需要在类内进行定义。所有在类外实现的定义都是公有的，代码如下：</span><br><span class="line">    class A:</span><br><span class="line">        __N = <span class="string">'hello'</span>      <span class="comment"># 此处是一个私有的类变量</span></span><br><span class="line"></span><br><span class="line">        def __init__(self):</span><br><span class="line">            self.__name = <span class="string">'tom'</span></span><br><span class="line"></span><br><span class="line">        def __method(self):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'我是私有函数'</span>)</span><br><span class="line"></span><br><span class="line">        def show(self):</span><br><span class="line">            self.__method()</span><br><span class="line">            <span class="built_in">print</span>(self.__name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    a = A()</span><br><span class="line">    A.__age = 10       <span class="comment"># 此处的__age是一个公有的类变量</span></span><br><span class="line">    <span class="built_in">print</span>(A.__age)</span><br><span class="line"></span><br><span class="line">8）property方法</span><br><span class="line">    在Python中，我们可以使用property来修饰指定的函数，被修饰后的函数，在类外可以通过对象调用（类似调用变量）</span><br><span class="line"></span><br><span class="line">    class Person:</span><br><span class="line">        def __init__(self, name, height, weight):</span><br><span class="line">            self.__name = name</span><br><span class="line">            self.__height = height</span><br><span class="line">            self.__weight = weight</span><br><span class="line">        </span><br><span class="line">        @property</span><br><span class="line">        def bmi(self):</span><br><span class="line">            <span class="built_in">return</span> self.__weight / self.__height**2</span><br><span class="line"></span><br><span class="line">    p = Person()</span><br><span class="line">    <span class="built_in">print</span>(p.bmi)  <span class="comment"># 此处调用的bmi是Person类中的函数。</span></span><br><span class="line">    原理：当类被载入时，首先会载入类的名称和被property修饰的名字到类的命名空间中；然后在类对象进行实例化时，Python解析器会查找是否存在property修饰的名字，如果存在，就不在实例化对象是为其分配内存空间。</span><br><span class="line"></span><br><span class="line">9）classmethod方法</span><br><span class="line">    在Python中，我们通常使用classmethod用来修饰一个方法，这个方法就被称为类方法，类方法通常用来操作类变量。类方法和类变量一样，都需要通过类名来调用。</span><br><span class="line">    class Goods:</span><br><span class="line">        __discount = 0.8</span><br><span class="line"></span><br><span class="line">        def __init__(self, name, price):</span><br><span class="line">            self.__name = name</span><br><span class="line">            self.__price = price</span><br><span class="line"></span><br><span class="line">        @classmethod</span><br><span class="line">        def change_discount(cls, new_discount): <span class="comment">#此处传递的默认参数不是对象参数self，而是类参数cls</span></span><br><span class="line">            cls.__discount = new_discount</span><br><span class="line">        </span><br><span class="line">        @classmethod</span><br><span class="line">        def get_discount(cls):</span><br><span class="line">            <span class="built_in">return</span> cls.__discount</span><br><span class="line"></span><br><span class="line">    goods = Goods(<span class="string">'apple'</span>, 6)</span><br><span class="line">    <span class="built_in">print</span>(Goods.get_discount())</span><br><span class="line">    Goods.change_discount(0.9)</span><br><span class="line">    <span class="built_in">print</span>(Goods.get_discount())</span><br><span class="line"></span><br><span class="line">10)staticmethod方法</span><br><span class="line">    在Python中，我们使用staticmethod来修饰函数，该函数被称为静态方法，首先，静态方法不需要使用对象参数或类参数作为默认参数。其次，静态方法通常只能调用类变量，而不可以使用成员变量。最后，在类外进行调用时，可以使用类名来调用。</span><br><span class="line"></span><br><span class="line">    实例方法、类方法与静态方法的区别</span><br><span class="line">    实例方法：第一个参数必须是实例对象（self）,通过它来传递实例的属性和方法，只能由实例对象来调用。</span><br><span class="line">    类方法：使用装饰器@classmethod，第一个参数必须是类对象（cls）,通过它来传递类的属性和方法。可以通过实例对象或类对象来调用，通常使用类对象调用。</span><br><span class="line">    静态方法：使用装饰器@staticmethod,没有默认参数（self和cls），但是方法体中不能使用类或实例对象的任何属性和方法。可以通过实例对象或类对象进行调用。</span><br><span class="line"></span><br><span class="line">    1、类方法和静态方法都可以通过对象实例或者类名来调用。</span><br><span class="line">    2、类方法主要针对的是类，可以通过继承和重新定义</span><br><span class="line">    3、静态方法不能被继承，无法被重写，可以被认为是全局函数。静态方法在使用时完全不会用到对象实例本身。静态方法逻辑上属于类，但是不会涉及到类中的属性和方法的操作。</span><br><span class="line"></span><br><span class="line">11）方法重写</span><br><span class="line">    概念：当子类继承父类时，子类会继承父类所有的公有方法。如果在子类中重写定义一个与父类中同名的方法，我们成为方法的重写（覆盖）。方法重写只需要名字相同即可，与方法的参数个数、顺序无关</span><br><span class="line"></span><br><span class="line">12）多态与鸭子类型</span><br><span class="line">    多态：多态一般都是通过继承来实现的，也就是根据不同的对象形态来进行区分。我们在Python中，使用多态时，意味着在编码时变量并不知道所引用的对象具体内容，只有在程序运行时相关对象被实例化后，才能够确定。</span><br><span class="line">    鸭子类型：在Python中，因为其自身特性并没有对多态进行明确的规定，可以创建一个功能相似，但与原对象无关的、全新对象，来实现程序的松耦合。</span><br><span class="line">    我们通常在开发中，采用接口的方式来实现。</span><br><span class="line">    我们认为在一组功能相似，但没有继承关系的对象中，采用接口方式。</span><br><span class="line">    class Payment:</span><br><span class="line">        def payment(self, money):</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class Weixinpay(Payment):</span><br><span class="line">        def payment(self, money):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'微信支付了&#123;0&#125;元'</span>.format(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class Alipay(Payment):</span><br><span class="line">        def payment(self, money):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'支付宝支付了&#123;0&#125;元'</span>.format(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    class My(Payment):</span><br><span class="line">        def payment(self, money):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'支付了&#123;0&#125;元'</span>.format(money))</span><br><span class="line"></span><br><span class="line">    此例，我们可以看到：</span><br><span class="line">    第一，通过继承，实现了多态，即三种支付方式不同的形态</span><br><span class="line">    第二，我们观察到，微信支付、支付宝、个人支付，三者之间没有任何继承关系，但是都具有相同的支付功能，我们可以认为这种形式就是鸭子类型</span><br><span class="line">    第三，因为三种支付方式，分别继承了接口类Payment，都重新了相关的支付方法payment()</span><br><span class="line"></span><br><span class="line">13)运算符重载</span><br><span class="line">    __getitem__：索引迭代</span><br><span class="line">    在Python，可迭代化对象在使用循环迭代时，都会默认的调用__iter__,如果没有next()方法，会调用__getitem__方法。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
